
(function(r,f) {
	var a=f();
	if(typeof a!=='object')return;
	var e=[typeof module==='object'&&typeof module.exports==='object'?module.exports:null,typeof window!=='undefined'?window:null,r&&r!==window?r:null];
	for(var i in a){e[0]&&(e[0][i]=a[i]);e[1]&&i!=='__esModule'&&(e[1][i] = a[i]);e[2]&&(e[2][i]=a[i]);}
})(this,function(){
	return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/shepherd/shepherd.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/*! exports provided: Shepherd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_shepherd_js_dist_js_shepherd_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/shepherd.js/dist/js/shepherd.js */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var _node_modules_shepherd_js_dist_js_shepherd_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_shepherd_js_dist_js_shepherd_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Shepherd\", function() { return _node_modules_shepherd_js_dist_js_shepherd_js__WEBPACK_IMPORTED_MODULE_0___default.a; });\n\n\n\n//# sourceURL=webpack:///./libs/shepherd/shepherd.js?");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n/*! shepherd.js 2.10.0 */\n(function (global, factory) {\n  ( false ? undefined : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n      _typeof = function _typeof(obj) {\n        return _typeof2(obj);\n      };\n    } else {\n      _typeof = function _typeof(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (_typeof2(call) === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n  /**\n   * lodash 4.0.0 (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   * Available under MIT license <https://lodash.com/license>\n   */\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n\n  function isObjectLike(value) {\n    return !!value && _typeof2(value) == 'object';\n  }\n\n  var lodash_isobjectlike = isObjectLike;\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `Number` object.\n   * @param {*} value The param to check if it is a number\n   */\n\n\n  function isNumber(value) {\n    return typeof value === 'number';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n  /**\n   * lodash 4.1.3 (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used for built-in method references. */\n\n\n  var objectProto = Object.prototype;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n      object[key] = value;\n    }\n  }\n  /**\n   * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n   *\n   * @private\n   * @param {Array} props The property identifiers.\n   * @param {Array} values The property values.\n   * @param {Function} assignFunc The function to assign values.\n   * @returns {Object} Returns the new object.\n   */\n\n\n  function baseZipObject(props, values, assignFunc) {\n    var index = -1,\n        length = props.length,\n        valsLength = values.length,\n        result = {};\n\n    while (++index < length) {\n      var value = index < valsLength ? values[index] : undefined;\n      assignFunc(result, props[index], value);\n    }\n\n    return result;\n  }\n  /**\n   * This method is like `_.fromPairs` except that it accepts two arrays,\n   * one of property identifiers and one of corresponding values.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.4.0\n   * @category Array\n   * @param {Array} [props=[]] The property identifiers.\n   * @param {Array} [values=[]] The property values.\n   * @returns {Object} Returns the new object.\n   * @example\n   *\n   * _.zipObject(['a', 'b'], [1, 2]);\n   * // => { 'a': 1, 'b': 2 }\n   */\n\n\n  function zipObject(props, values) {\n    return baseZipObject(props || [], values || [], assignValue);\n  }\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'user': 'fred' };\n   * var other = { 'user': 'fred' };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n\n\n  function eq(value, other) {\n    return value === other || value !== value && other !== other;\n  }\n\n  var lodash_zipobject = zipObject;\n  /**!\n   * @fileOverview Kickass library to create and place poppers near their reference elements.\n   * @version 1.15.0\n   * @license\n   * Copyright (c) 2016 Federico Zivolo and contributors\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in all\n   * copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   * SOFTWARE.\n   */\n\n  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  var timeoutDuration = 0;\n\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      timeoutDuration = 1;\n      break;\n    }\n  }\n\n  function microtaskDebounce(fn) {\n    var called = false;\n    return function () {\n      if (called) {\n        return;\n      }\n\n      called = true;\n      window.Promise.resolve().then(function () {\n        called = false;\n        fn();\n      });\n    };\n  }\n\n  function taskDebounce(fn) {\n    var scheduled = false;\n    return function () {\n      if (!scheduled) {\n        scheduled = true;\n        setTimeout(function () {\n          scheduled = false;\n          fn();\n        }, timeoutDuration);\n      }\n    };\n  }\n\n  var supportsMicroTasks = isBrowser && window.Promise;\n  /**\n  * Create a debounced version of a method, that's asynchronously deferred\n  * but called in the minimum time possible.\n  *\n  * @method\n  * @memberof Popper.Utils\n  * @argument {Function} fn\n  * @returns {Function}\n  */\n\n  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n  /**\n   * Check if the given variable is a function\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Any} functionToCheck - variable to check\n   * @returns {Boolean} answer to: is a function?\n   */\n\n  function isFunction$1(functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n  }\n  /**\n   * Get CSS computed property of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Eement} element\n   * @argument {String} property\n   */\n\n\n  function getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n      return [];\n    } // NOTE: 1 DOM access here\n\n\n    var window = element.ownerDocument.defaultView;\n    var css = window.getComputedStyle(element, null);\n    return property ? css[property] : css;\n  }\n  /**\n   * Returns the parentNode or the host of the element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} parent\n   */\n\n\n  function getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n      return element;\n    }\n\n    return element.parentNode || element.host;\n  }\n  /**\n   * Returns the scrolling parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} scroll parent\n   */\n\n\n  function getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n      return document.body;\n    }\n\n    switch (element.nodeName) {\n      case 'HTML':\n      case 'BODY':\n        return element.ownerDocument.body;\n\n      case '#document':\n        return element.body;\n    } // Firefox want us to check `-x` and `-y` variations as well\n\n\n    var _getStyleComputedProp = getStyleComputedProperty(element),\n        overflow = _getStyleComputedProp.overflow,\n        overflowX = _getStyleComputedProp.overflowX,\n        overflowY = _getStyleComputedProp.overflowY;\n\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      return element;\n    }\n\n    return getScrollParent(getParentNode(element));\n  }\n\n  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\n  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n  /**\n   * Determines if the browser is Internet Explorer\n   * @method\n   * @memberof Popper.Utils\n   * @param {Number} version to check\n   * @returns {Boolean} isIE\n   */\n\n  function isIE(version) {\n    if (version === 11) {\n      return isIE11;\n    }\n\n    if (version === 10) {\n      return isIE10;\n    }\n\n    return isIE11 || isIE10;\n  }\n  /**\n   * Returns the offset parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */\n\n\n  function getOffsetParent(element) {\n    if (!element) {\n      return document.documentElement;\n    }\n\n    var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here\n\n    var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent\n\n    while (offsetParent === noOffsetParent && element.nextElementSibling) {\n      offsetParent = (element = element.nextElementSibling).offsetParent;\n    }\n\n    var nodeName = offsetParent && offsetParent.nodeName;\n\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n      return element ? element.ownerDocument.documentElement : document.documentElement;\n    } // .offsetParent will return the closest TH, TD or TABLE in case\n    // no offsetParent is present, I hate this job...\n\n\n    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n      return getOffsetParent(offsetParent);\n    }\n\n    return offsetParent;\n  }\n\n  function isOffsetContainer(element) {\n    var nodeName = element.nodeName;\n\n    if (nodeName === 'BODY') {\n      return false;\n    }\n\n    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n  }\n  /**\n   * Finds the root node (document, shadowDOM root) of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} node\n   * @returns {Element} root node\n   */\n\n\n  function getRoot(node) {\n    if (node.parentNode !== null) {\n      return getRoot(node.parentNode);\n    }\n\n    return node;\n  }\n  /**\n   * Finds the offset parent common to the two provided nodes\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element1\n   * @argument {Element} element2\n   * @returns {Element} common offset parent\n   */\n\n\n  function findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n      return document.documentElement;\n    } // Here we make sure to give as \"start\" the element that comes first in the DOM\n\n\n    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    var start = order ? element1 : element2;\n    var end = order ? element2 : element1; // Get common ancestor container\n\n    var range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document\n\n    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n      if (isOffsetContainer(commonAncestorContainer)) {\n        return commonAncestorContainer;\n      }\n\n      return getOffsetParent(commonAncestorContainer);\n    } // one of the nodes is inside shadowDOM, find which one\n\n\n    var element1root = getRoot(element1);\n\n    if (element1root.host) {\n      return findCommonOffsetParent(element1root.host, element2);\n    } else {\n      return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n  }\n  /**\n   * Gets the scroll value of the given element in the given side (top and left)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {String} side `top` or `left`\n   * @returns {number} amount of scrolled pixels\n   */\n\n\n  function getScroll(element) {\n    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    var nodeName = element.nodeName;\n\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n      var html = element.ownerDocument.documentElement;\n      var scrollingElement = element.ownerDocument.scrollingElement || html;\n      return scrollingElement[upperSide];\n    }\n\n    return element[upperSide];\n  }\n  /*\n   * Sum or subtract the element scroll values (left and top) from a given rect object\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} rect - Rect object you want to change\n   * @param {HTMLElement} element - The element from the function reads the scroll values\n   * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n   * @return {Object} rect - The modifier rect object\n   */\n\n\n  function includeScroll(rect, element) {\n    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var scrollTop = getScroll(element, 'top');\n    var scrollLeft = getScroll(element, 'left');\n    var modifier = subtract ? -1 : 1;\n    rect.top += scrollTop * modifier;\n    rect.bottom += scrollTop * modifier;\n    rect.left += scrollLeft * modifier;\n    rect.right += scrollLeft * modifier;\n    return rect;\n  }\n  /*\n   * Helper to detect borders of a given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {CSSStyleDeclaration} styles\n   * Result of `getStyleComputedProperty` on the given element\n   * @param {String} axis - `x` or `y`\n   * @return {number} borders - The borders size of the given axis\n   */\n\n\n  function getBordersSize(styles, axis) {\n    var sideA = axis === 'x' ? 'Left' : 'Top';\n    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);\n  }\n\n  function getSize(axis, body, html, computedStyle) {\n    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n  }\n\n  function getWindowSizes(document) {\n    var body = document.body;\n    var html = document.documentElement;\n    var computedStyle = isIE(10) && getComputedStyle(html);\n    return {\n      height: getSize('Height', body, html, computedStyle),\n      width: getSize('Width', body, html, computedStyle)\n    };\n  }\n\n  var classCallCheck = function classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var defineProperty = function defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  };\n\n  var _extends$1 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  /**\n   * Given element offsets, generate an output similar to getBoundingClientRect\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} offsets\n   * @returns {Object} ClientRect like output\n   */\n\n\n  function getClientRect(offsets) {\n    return _extends$1({}, offsets, {\n      right: offsets.left + offsets.width,\n      bottom: offsets.top + offsets.height\n    });\n  }\n  /**\n   * Get bounding client rect of given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} element\n   * @return {Object} client rect\n   */\n\n\n  function getBoundingClientRect(element) {\n    var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n\n    try {\n      if (isIE(10)) {\n        rect = element.getBoundingClientRect();\n        var scrollTop = getScroll(element, 'top');\n        var scrollLeft = getScroll(element, 'left');\n        rect.top += scrollTop;\n        rect.left += scrollLeft;\n        rect.bottom += scrollTop;\n        rect.right += scrollLeft;\n      } else {\n        rect = element.getBoundingClientRect();\n      }\n    } catch (e) {}\n\n    var result = {\n      left: rect.left,\n      top: rect.top,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    }; // subtract scrollbar size from sizes\n\n    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n    var width = sizes.width || element.clientWidth || result.right - result.left;\n    var height = sizes.height || element.clientHeight || result.bottom - result.top;\n    var horizScrollbar = element.offsetWidth - width;\n    var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n\n    if (horizScrollbar || vertScrollbar) {\n      var styles = getStyleComputedProperty(element);\n      horizScrollbar -= getBordersSize(styles, 'x');\n      vertScrollbar -= getBordersSize(styles, 'y');\n      result.width -= horizScrollbar;\n      result.height -= vertScrollbar;\n    }\n\n    return getClientRect(result);\n  }\n\n  function getOffsetRectRelativeToArbitraryNode(children, parent) {\n    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var isIE10 = isIE(10);\n    var isHTML = parent.nodeName === 'HTML';\n    var childrenRect = getBoundingClientRect(children);\n    var parentRect = getBoundingClientRect(parent);\n    var scrollParent = getScrollParent(children);\n    var styles = getStyleComputedProperty(parent);\n    var borderTopWidth = parseFloat(styles.borderTopWidth, 10);\n    var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10); // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n\n    if (fixedPosition && isHTML) {\n      parentRect.top = Math.max(parentRect.top, 0);\n      parentRect.left = Math.max(parentRect.left, 0);\n    }\n\n    var offsets = getClientRect({\n      top: childrenRect.top - parentRect.top - borderTopWidth,\n      left: childrenRect.left - parentRect.left - borderLeftWidth,\n      width: childrenRect.width,\n      height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n\n    if (!isIE10 && isHTML) {\n      var marginTop = parseFloat(styles.marginTop, 10);\n      var marginLeft = parseFloat(styles.marginLeft, 10);\n      offsets.top -= borderTopWidth - marginTop;\n      offsets.bottom -= borderTopWidth - marginTop;\n      offsets.left -= borderLeftWidth - marginLeft;\n      offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them\n\n      offsets.marginTop = marginTop;\n      offsets.marginLeft = marginLeft;\n    }\n\n    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n      offsets = includeScroll(offsets, parent);\n    }\n\n    return offsets;\n  }\n\n  function getViewportOffsetRectRelativeToArtbitraryNode(element) {\n    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var html = element.ownerDocument.documentElement;\n    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    var width = Math.max(html.clientWidth, window.innerWidth || 0);\n    var height = Math.max(html.clientHeight, window.innerHeight || 0);\n    var scrollTop = !excludeScroll ? getScroll(html) : 0;\n    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    var offset = {\n      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n      width: width,\n      height: height\n    };\n    return getClientRect(offset);\n  }\n  /**\n   * Check if the given element is fixed or is inside a fixed parent\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {Element} customContainer\n   * @returns {Boolean} answer to \"isFixed?\"\n   */\n\n\n  function isFixed(element) {\n    var nodeName = element.nodeName;\n\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n      return false;\n    }\n\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n      return true;\n    }\n\n    var parentNode = getParentNode(element);\n\n    if (!parentNode) {\n      return false;\n    }\n\n    return isFixed(parentNode);\n  }\n  /**\n   * Finds the first parent of an element that has a transformed property defined\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} first transformed parent or documentElement\n   */\n\n\n  function getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE()) {\n      return document.documentElement;\n    }\n\n    var el = element.parentElement;\n\n    while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n      el = el.parentElement;\n    }\n\n    return el || document.documentElement;\n  }\n  /**\n   * Computed the boundaries limits and return them\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} popper\n   * @param {HTMLElement} reference\n   * @param {number} padding\n   * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n   * @param {Boolean} fixedPosition - Is in fixed position mode\n   * @returns {Object} Coordinates of the boundaries\n   */\n\n\n  function getBoundaries(popper, reference, padding, boundariesElement) {\n    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here\n\n    var boundaries = {\n      top: 0,\n      left: 0\n    };\n    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference); // Handle viewport case\n\n    if (boundariesElement === 'viewport') {\n      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    } else {\n      // Handle other cases based on DOM element used as boundaries\n      var boundariesNode = void 0;\n\n      if (boundariesElement === 'scrollParent') {\n        boundariesNode = getScrollParent(getParentNode(reference));\n\n        if (boundariesNode.nodeName === 'BODY') {\n          boundariesNode = popper.ownerDocument.documentElement;\n        }\n      } else if (boundariesElement === 'window') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      } else {\n        boundariesNode = boundariesElement;\n      }\n\n      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation\n\n      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n        var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n            height = _getWindowSizes.height,\n            width = _getWindowSizes.width;\n\n        boundaries.top += offsets.top - offsets.marginTop;\n        boundaries.bottom = height + offsets.top;\n        boundaries.left += offsets.left - offsets.marginLeft;\n        boundaries.right = width + offsets.left;\n      } else {\n        // for all the other DOM elements, this one is good\n        boundaries = offsets;\n      }\n    } // Add paddings\n\n\n    padding = padding || 0;\n    var isPaddingNumber = typeof padding === 'number';\n    boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n    boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n    return boundaries;\n  }\n\n  function getArea(_ref) {\n    var width = _ref.width,\n        height = _ref.height;\n    return width * height;\n  }\n  /**\n   * Utility used to transform the `auto` placement to the placement with more\n   * available space.\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    if (placement.indexOf('auto') === -1) {\n      return placement;\n    }\n\n    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n    var rects = {\n      top: {\n        width: boundaries.width,\n        height: refRect.top - boundaries.top\n      },\n      right: {\n        width: boundaries.right - refRect.right,\n        height: boundaries.height\n      },\n      bottom: {\n        width: boundaries.width,\n        height: boundaries.bottom - refRect.bottom\n      },\n      left: {\n        width: refRect.left - boundaries.left,\n        height: boundaries.height\n      }\n    };\n    var sortedAreas = Object.keys(rects).map(function (key) {\n      return _extends$1({\n        key: key\n      }, rects[key], {\n        area: getArea(rects[key])\n      });\n    }).sort(function (a, b) {\n      return b.area - a.area;\n    });\n    var filteredAreas = sortedAreas.filter(function (_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height;\n      return width >= popper.clientWidth && height >= popper.clientHeight;\n    });\n    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n    var variation = placement.split('-')[1];\n    return computedPlacement + (variation ? '-' + variation : '');\n  }\n  /**\n   * Get offsets to the reference element\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} state\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @param {Element} fixedPosition - is in fixed position mode\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */\n\n\n  function getReferenceOffsets(state, popper, reference) {\n    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n  }\n  /**\n   * Get the outer sizes of the given element (offset size + margins)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Object} object containing width and height properties\n   */\n\n\n  function getOuterSizes(element) {\n    var window = element.ownerDocument.defaultView;\n    var styles = window.getComputedStyle(element);\n    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n    var result = {\n      width: element.offsetWidth + y,\n      height: element.offsetHeight + x\n    };\n    return result;\n  }\n  /**\n   * Get the opposite placement of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement\n   * @returns {String} flipped placement\n   */\n\n\n  function getOppositePlacement(placement) {\n    var hash = {\n      left: 'right',\n      right: 'left',\n      bottom: 'top',\n      top: 'bottom'\n    };\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  /**\n   * Get offsets to the popper\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} position - CSS position the Popper will get applied\n   * @param {HTMLElement} popper - the popper element\n   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n   * @param {String} placement - one of the valid placement options\n   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n   */\n\n\n  function getPopperOffsets(popper, referenceOffsets, placement) {\n    placement = placement.split('-')[0]; // Get popper node sizes\n\n    var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object\n\n    var popperOffsets = {\n      width: popperRect.width,\n      height: popperRect.height\n    }; // depending by the popper placement we have to compute its offsets slightly differently\n\n    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    var mainSide = isHoriz ? 'top' : 'left';\n    var secondarySide = isHoriz ? 'left' : 'top';\n    var measurement = isHoriz ? 'height' : 'width';\n    var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n\n    if (placement === secondarySide) {\n      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n    } else {\n      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n    }\n\n    return popperOffsets;\n  }\n  /**\n   * Mimics the `find` method of Array\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n\n\n  function find(arr, check) {\n    // use native find if supported\n    if (Array.prototype.find) {\n      return arr.find(check);\n    } // use `filter` to obtain the same behavior of `find`\n\n\n    return arr.filter(check)[0];\n  }\n  /**\n   * Return the index of the matching object\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n\n\n  function findIndex(arr, prop, value) {\n    // use native findIndex if supported\n    if (Array.prototype.findIndex) {\n      return arr.findIndex(function (cur) {\n        return cur[prop] === value;\n      });\n    } // use `find` + `indexOf` if `findIndex` isn't supported\n\n\n    var match = find(arr, function (obj) {\n      return obj[prop] === value;\n    });\n    return arr.indexOf(match);\n  }\n  /**\n   * Loop trough the list of modifiers and run them in order,\n   * each of them will then edit the data object.\n   * @method\n   * @memberof Popper.Utils\n   * @param {dataObject} data\n   * @param {Array} modifiers\n   * @param {String} ends - Optional modifier name used as stopper\n   * @returns {dataObject}\n   */\n\n\n  function runModifiers(modifiers, data, ends) {\n    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n    modifiersToRun.forEach(function (modifier) {\n      if (modifier['function']) {\n        // eslint-disable-line dot-notation\n        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n      }\n\n      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n\n      if (modifier.enabled && isFunction$1(fn)) {\n        // Add properties to offsets to make them a complete clientRect object\n        // we do this before each modifier to make sure the previous one doesn't\n        // mess with these values\n        data.offsets.popper = getClientRect(data.offsets.popper);\n        data.offsets.reference = getClientRect(data.offsets.reference);\n        data = fn(data, modifier);\n      }\n    });\n    return data;\n  }\n  /**\n   * Updates the position of the popper, computing the new offsets and applying\n   * the new style.<br />\n   * Prefer `scheduleUpdate` over `update` because of performance reasons.\n   * @method\n   * @memberof Popper\n   */\n\n\n  function update() {\n    // if popper is destroyed, don't perform any further update\n    if (this.state.isDestroyed) {\n      return;\n    }\n\n    var data = {\n      instance: this,\n      styles: {},\n      arrowStyles: {},\n      attributes: {},\n      flipped: false,\n      offsets: {}\n    }; // compute reference element offsets\n\n    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n\n    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`\n\n    data.originalPlacement = data.placement;\n    data.positionFixed = this.options.positionFixed; // compute the popper offsets\n\n    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers\n\n    data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback\n    // the other ones will call `onUpdate` callback\n\n    if (!this.state.isCreated) {\n      this.state.isCreated = true;\n      this.options.onCreate(data);\n    } else {\n      this.options.onUpdate(data);\n    }\n  }\n  /**\n   * Helper used to know if the given modifier is enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @returns {Boolean}\n   */\n\n\n  function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(function (_ref) {\n      var name = _ref.name,\n          enabled = _ref.enabled;\n      return enabled && name === modifierName;\n    });\n  }\n  /**\n   * Get the prefixed supported property name\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} property (camelCase)\n   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n   */\n\n\n  function getSupportedPropertyName(property) {\n    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i];\n      var toCheck = prefix ? '' + prefix + upperProp : property;\n\n      if (typeof document.body.style[toCheck] !== 'undefined') {\n        return toCheck;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Destroys the popper.\n   * @method\n   * @memberof Popper\n   */\n\n\n  function destroy() {\n    this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled\n\n    if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n      this.popper.removeAttribute('x-placement');\n      this.popper.style.position = '';\n      this.popper.style.top = '';\n      this.popper.style.left = '';\n      this.popper.style.right = '';\n      this.popper.style.bottom = '';\n      this.popper.style.willChange = '';\n      this.popper.style[getSupportedPropertyName('transform')] = '';\n    }\n\n    this.disableEventListeners(); // remove the popper if user explicity asked for the deletion on destroy\n    // do not use `remove` because IE11 doesn't support it\n\n    if (this.options.removeOnDestroy) {\n      this.popper.parentNode.removeChild(this.popper);\n    }\n\n    return this;\n  }\n  /**\n   * Get the window associated with the element\n   * @argument {Element} element\n   * @returns {Window}\n   */\n\n\n  function getWindow(element) {\n    var ownerDocument = element.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n\n  function attachToScrollParents(scrollParent, event, callback, scrollParents) {\n    var isBody = scrollParent.nodeName === 'BODY';\n    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n    target.addEventListener(event, callback, {\n      passive: true\n    });\n\n    if (!isBody) {\n      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n    }\n\n    scrollParents.push(target);\n  }\n  /**\n   * Setup needed event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n\n\n  function setupEventListeners(reference, options, state, updateBound) {\n    // Resize event listener on window\n    state.updateBound = updateBound;\n    getWindow(reference).addEventListener('resize', state.updateBound, {\n      passive: true\n    }); // Scroll event listener on scroll parents\n\n    var scrollElement = getScrollParent(reference);\n    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n    state.scrollElement = scrollElement;\n    state.eventsEnabled = true;\n    return state;\n  }\n  /**\n   * It will add resize/scroll events and start recalculating\n   * position of the popper element when they are triggered.\n   * @method\n   * @memberof Popper\n   */\n\n\n  function enableEventListeners() {\n    if (!this.state.eventsEnabled) {\n      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n    }\n  }\n  /**\n   * Remove event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n\n\n  function removeEventListeners(reference, state) {\n    // Remove resize event listener on window\n    getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents\n\n    state.scrollParents.forEach(function (target) {\n      target.removeEventListener('scroll', state.updateBound);\n    }); // Reset state\n\n    state.updateBound = null;\n    state.scrollParents = [];\n    state.scrollElement = null;\n    state.eventsEnabled = false;\n    return state;\n  }\n  /**\n   * It will remove resize/scroll events and won't recalculate popper position\n   * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n   * unless you call `update` method manually.\n   * @method\n   * @memberof Popper\n   */\n\n\n  function disableEventListeners() {\n    if (this.state.eventsEnabled) {\n      cancelAnimationFrame(this.scheduleUpdate);\n      this.state = removeEventListeners(this.reference, this.state);\n    }\n  }\n  /**\n   * Tells if a given input is a number\n   * @method\n   * @memberof Popper.Utils\n   * @param {*} input to check\n   * @return {Boolean}\n   */\n\n\n  function isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n  }\n  /**\n   * Set the style to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the style to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */\n\n\n  function setStyles(element, styles) {\n    Object.keys(styles).forEach(function (prop) {\n      var unit = ''; // add unit if the value is numeric and is one of the following\n\n      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n        unit = 'px';\n      }\n\n      element.style[prop] = styles[prop] + unit;\n    });\n  }\n  /**\n   * Set the attributes to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the attributes to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */\n\n\n  function setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function (prop) {\n      var value = attributes[prop];\n\n      if (value !== false) {\n        element.setAttribute(prop, attributes[prop]);\n      } else {\n        element.removeAttribute(prop);\n      }\n    });\n  }\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} data.styles - List of style properties - values to apply to popper element\n   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The same data object\n   */\n\n\n  function applyStyle(data) {\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n\n    setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties\n\n    if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n      setStyles(data.arrowElement, data.arrowStyles);\n    }\n\n    return data;\n  }\n  /**\n   * Set the x-placement attribute before everything else because it could be used\n   * to add margins to the popper margins needs to be calculated to get the\n   * correct popper offsets.\n   * @method\n   * @memberof Popper.modifiers\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper\n   * @param {Object} options - Popper.js options\n   */\n\n\n  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    // compute reference element offsets\n    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n\n    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n    popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because\n    // without the position applied we can't guarantee correct computations\n\n    setStyles(popper, {\n      position: options.positionFixed ? 'fixed' : 'absolute'\n    });\n    return options;\n  }\n  /**\n   * @function\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n   * @returns {Object} The popper's position offsets rounded\n   *\n   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n   * good as it can be within reason.\n   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n   *\n   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n   * as well on High DPI screens).\n   *\n   * Firefox prefers no rounding for positioning and does not have blurriness on\n   * high DPI screens.\n   *\n   * Only horizontal placement and left/right values need to be considered.\n   */\n\n\n  function getRoundedOffsets(data, shouldRound) {\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n    var round = Math.round,\n        floor = Math.floor;\n\n    var noRound = function noRound(v) {\n      return v;\n    };\n\n    var referenceWidth = round(reference.width);\n    var popperWidth = round(popper.width);\n    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n    var isVariation = data.placement.indexOf('-') !== -1;\n    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n    var verticalToInteger = !shouldRound ? noRound : round;\n    return {\n      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n      top: verticalToInteger(popper.top),\n      bottom: verticalToInteger(popper.bottom),\n      right: horizontalToInteger(popper.right)\n    };\n  }\n\n  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n  function computeStyle(data, options) {\n    var x = options.x,\n        y = options.y;\n    var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2\n\n    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n      return modifier.name === 'applyStyle';\n    }).gpuAcceleration;\n\n    if (legacyGpuAccelerationOption !== undefined) {\n      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n    }\n\n    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n    var offsetParent = getOffsetParent(data.instance.popper);\n    var offsetParentRect = getBoundingClientRect(offsetParent); // Styles\n\n    var styles = {\n      position: popper.position\n    };\n    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n    var sideA = x === 'bottom' ? 'top' : 'bottom';\n    var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n\n    var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)\n    // If the content of the popper grows once it's been positioned, it\n    // may happen that the popper gets misplaced because of the new content\n    // overflowing its reference element\n    // To avoid this problem, we provide two options (x and y), which allow\n    // the consumer to define the offset origin.\n    // If we position a popper on top of a reference element, we can set\n    // `x` to `top` to make the popper grow towards its top instead of\n    // its bottom.\n\n    var left = void 0,\n        top = void 0;\n\n    if (sideA === 'bottom') {\n      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n      // and not the bottom of the html element\n      if (offsetParent.nodeName === 'HTML') {\n        top = -offsetParent.clientHeight + offsets.bottom;\n      } else {\n        top = -offsetParentRect.height + offsets.bottom;\n      }\n    } else {\n      top = offsets.top;\n    }\n\n    if (sideB === 'right') {\n      if (offsetParent.nodeName === 'HTML') {\n        left = -offsetParent.clientWidth + offsets.right;\n      } else {\n        left = -offsetParentRect.width + offsets.right;\n      }\n    } else {\n      left = offsets.left;\n    }\n\n    if (gpuAcceleration && prefixedProperty) {\n      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n      styles[sideA] = 0;\n      styles[sideB] = 0;\n      styles.willChange = 'transform';\n    } else {\n      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n      var invertTop = sideA === 'bottom' ? -1 : 1;\n      var invertLeft = sideB === 'right' ? -1 : 1;\n      styles[sideA] = top * invertTop;\n      styles[sideB] = left * invertLeft;\n      styles.willChange = sideA + ', ' + sideB;\n    } // Attributes\n\n\n    var attributes = {\n      'x-placement': data.placement\n    }; // Update `data` attributes, styles and arrowStyles\n\n    data.attributes = _extends$1({}, attributes, data.attributes);\n    data.styles = _extends$1({}, styles, data.styles);\n    data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);\n    return data;\n  }\n  /**\n   * Helper used to know if the given modifier depends from another one.<br />\n   * It checks if the needed modifier is listed and enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Array} modifiers - list of modifiers\n   * @param {String} requestingName - name of requesting modifier\n   * @param {String} requestedName - name of requested modifier\n   * @returns {Boolean}\n   */\n\n\n  function isModifierRequired(modifiers, requestingName, requestedName) {\n    var requesting = find(modifiers, function (_ref) {\n      var name = _ref.name;\n      return name === requestingName;\n    });\n    var isRequired = !!requesting && modifiers.some(function (modifier) {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n\n    if (!isRequired) {\n      var _requesting = '`' + requestingName + '`';\n\n      var requested = '`' + requestedName + '`';\n      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n    }\n\n    return isRequired;\n  }\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  function arrow(data, options) {\n    var _data$offsets$arrow; // arrow depends on keepTogether in order to work\n\n\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n      return data;\n    }\n\n    var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier\n\n      if (!arrowElement) {\n        return data;\n      }\n    } else {\n      // if the arrowElement isn't a query selector we must check that the\n      // provided DOM node is child of its popper node\n      if (!data.instance.popper.contains(arrowElement)) {\n        console.warn('WARNING: `arrow.element` must be child of its popper element!');\n        return data;\n      }\n    }\n\n    var placement = data.placement.split('-')[0];\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n    var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n    var len = isVertical ? 'height' : 'width';\n    var sideCapitalized = isVertical ? 'Top' : 'Left';\n    var side = sideCapitalized.toLowerCase();\n    var altSide = isVertical ? 'left' : 'top';\n    var opSide = isVertical ? 'bottom' : 'right';\n    var arrowElementSize = getOuterSizes(arrowElement)[len]; //\n    // extends keepTogether behavior making sure the popper and its\n    // reference have enough pixels in conjunction\n    //\n    // top/left side\n\n    if (reference[opSide] - arrowElementSize < popper[side]) {\n      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n    } // bottom/right side\n\n\n    if (reference[side] + arrowElementSize > popper[opSide]) {\n      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n    }\n\n    data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper\n\n    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets\n    // take popper margin in account because we don't have this info available\n\n    var css = getStyleComputedProperty(data.instance.popper);\n    var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);\n    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);\n    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper\n\n    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n    data.arrowElement = arrowElement;\n    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n    return data;\n  }\n  /**\n   * Get the opposite placement variation of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement variation\n   * @returns {String} flipped placement variation\n   */\n\n\n  function getOppositeVariation(variation) {\n    if (variation === 'end') {\n      return 'start';\n    } else if (variation === 'start') {\n      return 'end';\n    }\n\n    return variation;\n  }\n  /**\n   * List of accepted placements to use as values of the `placement` option.<br />\n   * Valid placements are:\n   * - `auto`\n   * - `top`\n   * - `right`\n   * - `bottom`\n   * - `left`\n   *\n   * Each placement can have a variation from this list:\n   * - `-start`\n   * - `-end`\n   *\n   * Variations are interpreted easily if you think of them as the left to right\n   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n   * is right.<br />\n   * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n   *\n   * Some valid examples are:\n   * - `top-end` (on top of reference, right aligned)\n   * - `right-start` (on right of reference, top aligned)\n   * - `bottom` (on bottom, centered)\n   * - `auto-end` (on the side with more space available, alignment depends by placement)\n   *\n   * @static\n   * @type {Array}\n   * @enum {String}\n   * @readonly\n   * @method placements\n   * @memberof Popper\n   */\n\n\n  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`\n\n  var validPlacements = placements.slice(3);\n  /**\n   * Given an initial placement, returns all the subsequent placements\n   * clockwise (or counter-clockwise).\n   *\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement - A valid placement (it accepts variations)\n   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n   * @returns {Array} placements including their variations\n   */\n\n  function clockwise(placement) {\n    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var index = validPlacements.indexOf(placement);\n    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n    return counter ? arr.reverse() : arr;\n  }\n\n  var BEHAVIORS = {\n    FLIP: 'flip',\n    CLOCKWISE: 'clockwise',\n    COUNTERCLOCKWISE: 'counterclockwise'\n  };\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n  function flip(data, options) {\n    // if `inner` modifier is enabled, we can't use the `flip` modifier\n    if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n      return data;\n    }\n\n    if (data.flipped && data.placement === data.originalPlacement) {\n      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n      return data;\n    }\n\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n    var placement = data.placement.split('-')[0];\n    var placementOpposite = getOppositePlacement(placement);\n    var variation = data.placement.split('-')[1] || '';\n    var flipOrder = [];\n\n    switch (options.behavior) {\n      case BEHAVIORS.FLIP:\n        flipOrder = [placement, placementOpposite];\n        break;\n\n      case BEHAVIORS.CLOCKWISE:\n        flipOrder = clockwise(placement);\n        break;\n\n      case BEHAVIORS.COUNTERCLOCKWISE:\n        flipOrder = clockwise(placement, true);\n        break;\n\n      default:\n        flipOrder = options.behavior;\n    }\n\n    flipOrder.forEach(function (step, index) {\n      if (placement !== step || flipOrder.length === index + 1) {\n        return data;\n      }\n\n      placement = data.placement.split('-')[0];\n      placementOpposite = getOppositePlacement(placement);\n      var popperOffsets = data.offsets.popper;\n      var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here\n\n      var floor = Math.floor;\n      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required\n\n      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries\n\n      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries\n\n      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n      var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n      if (overlapsRef || overflowsBoundaries || flippedVariation) {\n        // this boolean to detect any flip loop\n        data.flipped = true;\n\n        if (overlapsRef || overflowsBoundaries) {\n          placement = flipOrder[index + 1];\n        }\n\n        if (flippedVariation) {\n          variation = getOppositeVariation(variation);\n        }\n\n        data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with\n        // any additional property we may add in the future\n\n        data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n        data = runModifiers(data.instance.modifiers, data, 'flip');\n      }\n    });\n    return data;\n  }\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  function keepTogether(data) {\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n    var placement = data.placement.split('-')[0];\n    var floor = Math.floor;\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var side = isVertical ? 'right' : 'bottom';\n    var opSide = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    if (popper[side] < floor(reference[opSide])) {\n      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n    }\n\n    if (popper[opSide] > floor(reference[side])) {\n      data.offsets.popper[opSide] = floor(reference[side]);\n    }\n\n    return data;\n  }\n  /**\n   * Converts a string containing value + unit into a px value number\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} str - Value + unit string\n   * @argument {String} measurement - `height` or `width`\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @returns {Number|String}\n   * Value in pixels, or original string if no values were extracted\n   */\n\n\n  function toValue(str, measurement, popperOffsets, referenceOffsets) {\n    // separate value from unit\n    var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n    var value = +split[1];\n    var unit = split[2]; // If it's not a number it's an operator, I guess\n\n    if (!value) {\n      return str;\n    }\n\n    if (unit.indexOf('%') === 0) {\n      var element = void 0;\n\n      switch (unit) {\n        case '%p':\n          element = popperOffsets;\n          break;\n\n        case '%':\n        case '%r':\n        default:\n          element = referenceOffsets;\n      }\n\n      var rect = getClientRect(element);\n      return rect[measurement] / 100 * value;\n    } else if (unit === 'vh' || unit === 'vw') {\n      // if is a vh or vw, we calculate the size based on the viewport\n      var size = void 0;\n\n      if (unit === 'vh') {\n        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n      } else {\n        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n      }\n\n      return size / 100 * value;\n    } else {\n      // if is an explicit pixel unit, we get rid of the unit and keep the value\n      // if is an implicit unit, it's px, and we return just the value\n      return value;\n    }\n  }\n  /**\n   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} offset\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @argument {String} basePlacement\n   * @returns {Array} a two cells array with x and y offsets in numbers\n   */\n\n\n  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n    var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width\n    // in this way the first offset will use an axis and the second one\n    // will use the other one\n\n    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands\n    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n\n    var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n      return frag.trim();\n    }); // Detect if the offset string contains a pair of values or a single one\n    // they could be separated by comma or space\n\n    var divider = fragments.indexOf(find(fragments, function (frag) {\n      return frag.search(/,|\\s/) !== -1;\n    }));\n\n    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n    } // If divider is found, we divide the list of values and operands to divide\n    // them by ofset X and Y.\n\n\n    var splitRegex = /\\s*,\\s*|\\s+/;\n    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations\n\n    ops = ops.map(function (op, index) {\n      // Most of the units rely on the orientation of the popper\n      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n      var mergeWithPrevious = false;\n      return op // This aggregates any `+` or `-` sign that aren't considered operators\n      // e.g.: 10 + +5 => [10, +, +5]\n      .reduce(function (a, b) {\n        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n          a[a.length - 1] = b;\n          mergeWithPrevious = true;\n          return a;\n        } else if (mergeWithPrevious) {\n          a[a.length - 1] += b;\n          mergeWithPrevious = false;\n          return a;\n        } else {\n          return a.concat(b);\n        }\n      }, []) // Here we convert the string values into number values (in px)\n      .map(function (str) {\n        return toValue(str, measurement, popperOffsets, referenceOffsets);\n      });\n    }); // Loop trough the offsets arrays and execute the operations\n\n    ops.forEach(function (op, index) {\n      op.forEach(function (frag, index2) {\n        if (isNumeric(frag)) {\n          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n        }\n      });\n    });\n    return offsets;\n  }\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @argument {Number|String} options.offset=0\n   * The offset value as described in the modifier description\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  function offset(data, _ref) {\n    var offset = _ref.offset;\n    var placement = data.placement,\n        _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n    var basePlacement = placement.split('-')[0];\n    var offsets = void 0;\n\n    if (isNumeric(+offset)) {\n      offsets = [+offset, 0];\n    } else {\n      offsets = parseOffset(offset, popper, reference, basePlacement);\n    }\n\n    if (basePlacement === 'left') {\n      popper.top += offsets[0];\n      popper.left -= offsets[1];\n    } else if (basePlacement === 'right') {\n      popper.top += offsets[0];\n      popper.left += offsets[1];\n    } else if (basePlacement === 'top') {\n      popper.left += offsets[0];\n      popper.top -= offsets[1];\n    } else if (basePlacement === 'bottom') {\n      popper.left += offsets[0];\n      popper.top += offsets[1];\n    }\n\n    data.popper = popper;\n    return data;\n  }\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  function preventOverflow(data, options) {\n    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to\n    // go one step up and use the next offsetParent as reference to\n    // avoid to make this modifier completely useless and look like broken\n\n    if (data.instance.reference === boundariesElement) {\n      boundariesElement = getOffsetParent(boundariesElement);\n    } // NOTE: DOM access here\n    // resets the popper's position so that the document size can be calculated excluding\n    // the size of the popper element itself\n\n\n    var transformProp = getSupportedPropertyName('transform');\n    var popperStyles = data.instance.popper.style; // assignment to help minification\n\n    var top = popperStyles.top,\n        left = popperStyles.left,\n        transform = popperStyles[transformProp];\n    popperStyles.top = '';\n    popperStyles.left = '';\n    popperStyles[transformProp] = '';\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n\n    popperStyles.top = top;\n    popperStyles.left = left;\n    popperStyles[transformProp] = transform;\n    options.boundaries = boundaries;\n    var order = options.priority;\n    var popper = data.offsets.popper;\n    var check = {\n      primary: function primary(placement) {\n        var value = popper[placement];\n\n        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n          value = Math.max(popper[placement], boundaries[placement]);\n        }\n\n        return defineProperty({}, placement, value);\n      },\n      secondary: function secondary(placement) {\n        var mainSide = placement === 'right' ? 'left' : 'top';\n        var value = popper[mainSide];\n\n        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n        }\n\n        return defineProperty({}, mainSide, value);\n      }\n    };\n    order.forEach(function (placement) {\n      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n      popper = _extends$1({}, popper, check[side](placement));\n    });\n    data.offsets.popper = popper;\n    return data;\n  }\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  function shift(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier\n\n    if (shiftvariation) {\n      var _data$offsets = data.offsets,\n          reference = _data$offsets.reference,\n          popper = _data$offsets.popper;\n      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n      var side = isVertical ? 'left' : 'top';\n      var measurement = isVertical ? 'width' : 'height';\n      var shiftOffsets = {\n        start: defineProperty({}, side, reference[side]),\n        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n      };\n      data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);\n    }\n\n    return data;\n  }\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  function hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n      return data;\n    }\n\n    var refRect = data.offsets.reference;\n    var bound = find(data.instance.modifiers, function (modifier) {\n      return modifier.name === 'preventOverflow';\n    }).boundaries;\n\n    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n      // Avoid unnecessary DOM access if visibility hasn't changed\n      if (data.hide === true) {\n        return data;\n      }\n\n      data.hide = true;\n      data.attributes['x-out-of-boundaries'] = '';\n    } else {\n      // Avoid unnecessary DOM access if visibility hasn't changed\n      if (data.hide === false) {\n        return data;\n      }\n\n      data.hide = false;\n      data.attributes['x-out-of-boundaries'] = false;\n    }\n\n    return data;\n  }\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  function inner(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var _data$offsets = data.offsets,\n        popper = _data$offsets.popper,\n        reference = _data$offsets.reference;\n    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n    data.placement = getOppositePlacement(placement);\n    data.offsets.popper = getClientRect(popper);\n    return data;\n  }\n  /**\n   * Modifier function, each modifier can have a function of this type assigned\n   * to its `fn` property.<br />\n   * These functions will be called on each update, this means that you must\n   * make sure they are performant enough to avoid performance bottlenecks.\n   *\n   * @function ModifierFn\n   * @argument {dataObject} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {dataObject} The data object, properly modified\n   */\n\n  /**\n   * Modifiers are plugins used to alter the behavior of your poppers.<br />\n   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n   * needed by the library.\n   *\n   * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n   * All the other properties are configurations that could be tweaked.\n   * @namespace modifiers\n   */\n\n\n  var modifiers = {\n    /**\n     * Modifier used to shift the popper on the start or end of its reference\n     * element.<br />\n     * It will read the variation of the `placement` property.<br />\n     * It can be one either `-end` or `-start`.\n     * @memberof modifiers\n     * @inner\n     */\n    shift: {\n      /** @prop {number} order=100 - Index used to define the order of execution */\n      order: 100,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: shift\n    },\n\n    /**\n     * The `offset` modifier can shift your popper on both its axis.\n     *\n     * It accepts the following units:\n     * - `px` or unit-less, interpreted as pixels\n     * - `%` or `%r`, percentage relative to the length of the reference element\n     * - `%p`, percentage relative to the length of the popper element\n     * - `vw`, CSS viewport width unit\n     * - `vh`, CSS viewport height unit\n     *\n     * For length is intended the main axis relative to the placement of the popper.<br />\n     * This means that if the placement is `top` or `bottom`, the length will be the\n     * `width`. In case of `left` or `right`, it will be the `height`.\n     *\n     * You can provide a single value (as `Number` or `String`), or a pair of values\n     * as `String` divided by a comma or one (or more) white spaces.<br />\n     * The latter is a deprecated method because it leads to confusion and will be\n     * removed in v2.<br />\n     * Additionally, it accepts additions and subtractions between different units.\n     * Note that multiplications and divisions aren't supported.\n     *\n     * Valid examples are:\n     * ```\n     * 10\n     * '10%'\n     * '10, 10'\n     * '10%, 10'\n     * '10 + 10%'\n     * '10 - 5vh + 3%'\n     * '-10px + 5vh, 5px - 6%'\n     * ```\n     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    offset: {\n      /** @prop {number} order=200 - Index used to define the order of execution */\n      order: 200,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: offset,\n\n      /** @prop {Number|String} offset=0\n       * The offset value as described in the modifier description\n       */\n      offset: 0\n    },\n\n    /**\n     * Modifier used to prevent the popper from being positioned outside the boundary.\n     *\n     * A scenario exists where the reference itself is not within the boundaries.<br />\n     * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n     * In this case we need to decide whether the popper should either:\n     *\n     * - detach from the reference and remain \"trapped\" in the boundaries, or\n     * - if it should ignore the boundary and \"escape with its reference\"\n     *\n     * When `escapeWithReference` is set to`true` and reference is completely\n     * outside its boundaries, the popper will overflow (or completely leave)\n     * the boundaries in order to remain attached to the edge of the reference.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    preventOverflow: {\n      /** @prop {number} order=300 - Index used to define the order of execution */\n      order: 300,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: preventOverflow,\n\n      /**\n       * @prop {Array} [priority=['left','right','top','bottom']]\n       * Popper will try to prevent overflow following these priorities by default,\n       * then, it could overflow on the left and on top of the `boundariesElement`\n       */\n      priority: ['left', 'right', 'top', 'bottom'],\n\n      /**\n       * @prop {number} padding=5\n       * Amount of pixel used to define a minimum distance between the boundaries\n       * and the popper. This makes sure the popper always has a little padding\n       * between the edges of its container\n       */\n      padding: 5,\n\n      /**\n       * @prop {String|HTMLElement} boundariesElement='scrollParent'\n       * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n       * `viewport` or any DOM element.\n       */\n      boundariesElement: 'scrollParent'\n    },\n\n    /**\n     * Modifier used to make sure the reference and its popper stay near each other\n     * without leaving any gap between the two. Especially useful when the arrow is\n     * enabled and you want to ensure that it points to its reference element.\n     * It cares only about the first axis. You can still have poppers with margin\n     * between the popper and its reference element.\n     * @memberof modifiers\n     * @inner\n     */\n    keepTogether: {\n      /** @prop {number} order=400 - Index used to define the order of execution */\n      order: 400,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: keepTogether\n    },\n\n    /**\n     * This modifier is used to move the `arrowElement` of the popper to make\n     * sure it is positioned between the reference element and its popper element.\n     * It will read the outer size of the `arrowElement` node to detect how many\n     * pixels of conjunction are needed.\n     *\n     * It has no effect if no `arrowElement` is provided.\n     * @memberof modifiers\n     * @inner\n     */\n    arrow: {\n      /** @prop {number} order=500 - Index used to define the order of execution */\n      order: 500,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: arrow,\n\n      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n      element: '[x-arrow]'\n    },\n\n    /**\n     * Modifier used to flip the popper's placement when it starts to overlap its\n     * reference element.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     *\n     * **NOTE:** this modifier will interrupt the current update cycle and will\n     * restart it if it detects the need to flip the placement.\n     * @memberof modifiers\n     * @inner\n     */\n    flip: {\n      /** @prop {number} order=600 - Index used to define the order of execution */\n      order: 600,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: flip,\n\n      /**\n       * @prop {String|Array} behavior='flip'\n       * The behavior used to change the popper's placement. It can be one of\n       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n       * placements (with optional variations)\n       */\n      behavior: 'flip',\n\n      /**\n       * @prop {number} padding=5\n       * The popper will flip if it hits the edges of the `boundariesElement`\n       */\n      padding: 5,\n\n      /**\n       * @prop {String|HTMLElement} boundariesElement='viewport'\n       * The element which will define the boundaries of the popper position.\n       * The popper will never be placed outside of the defined boundaries\n       * (except if `keepTogether` is enabled)\n       */\n      boundariesElement: 'viewport',\n\n      /**\n       * @prop {Boolean} flipVariations=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the reference element overlaps its boundaries.\n       *\n       * The original placement should have a set variation.\n       */\n      flipVariations: false,\n\n      /**\n       * @prop {Boolean} flipVariationsByContent=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the popper element overlaps its reference boundaries.\n       *\n       * The original placement should have a set variation.\n       */\n      flipVariationsByContent: false\n    },\n\n    /**\n     * Modifier used to make the popper flow toward the inner of the reference element.\n     * By default, when this modifier is disabled, the popper will be placed outside\n     * the reference element.\n     * @memberof modifiers\n     * @inner\n     */\n    inner: {\n      /** @prop {number} order=700 - Index used to define the order of execution */\n      order: 700,\n\n      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n      enabled: false,\n\n      /** @prop {ModifierFn} */\n      fn: inner\n    },\n\n    /**\n     * Modifier used to hide the popper when its reference element is outside of the\n     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n     * be used to hide with a CSS selector the popper when its reference is\n     * out of boundaries.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     * @memberof modifiers\n     * @inner\n     */\n    hide: {\n      /** @prop {number} order=800 - Index used to define the order of execution */\n      order: 800,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: hide\n    },\n\n    /**\n     * Computes the style that will be applied to the popper element to gets\n     * properly positioned.\n     *\n     * Note that this modifier will not touch the DOM, it just prepares the styles\n     * so that `applyStyle` modifier can apply it. This separation is useful\n     * in case you need to replace `applyStyle` with a custom implementation.\n     *\n     * This modifier has `850` as `order` value to maintain backward compatibility\n     * with previous versions of Popper.js. Expect the modifiers ordering method\n     * to change in future major versions of the library.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    computeStyle: {\n      /** @prop {number} order=850 - Index used to define the order of execution */\n      order: 850,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: computeStyle,\n\n      /**\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */\n      gpuAcceleration: true,\n\n      /**\n       * @prop {string} [x='bottom']\n       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n       * Change this if your popper should grow in a direction different from `bottom`\n       */\n      x: 'bottom',\n\n      /**\n       * @prop {string} [x='left']\n       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n       * Change this if your popper should grow in a direction different from `right`\n       */\n      y: 'right'\n    },\n\n    /**\n     * Applies the computed styles to the popper element.\n     *\n     * All the DOM manipulations are limited to this modifier. This is useful in case\n     * you want to integrate Popper.js inside a framework or view library and you\n     * want to delegate all the DOM manipulations to it.\n     *\n     * Note that if you disable this modifier, you must make sure the popper element\n     * has its position set to `absolute` before Popper.js can do its work!\n     *\n     * Just disable this modifier and define your own to achieve the desired effect.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    applyStyle: {\n      /** @prop {number} order=900 - Index used to define the order of execution */\n      order: 900,\n\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n\n      /** @prop {ModifierFn} */\n      fn: applyStyle,\n\n      /** @prop {Function} */\n      onLoad: applyStyleOnLoad,\n\n      /**\n       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */\n      gpuAcceleration: undefined\n    }\n  };\n  /**\n   * The `dataObject` is an object containing all the information used by Popper.js.\n   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n   * @name dataObject\n   * @property {Object} data.instance The Popper.js instance\n   * @property {String} data.placement Placement applied to popper\n   * @property {String} data.originalPlacement Placement originally defined on init\n   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.boundaries Offsets of the popper boundaries\n   * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n   */\n\n  /**\n   * Default options provided to Popper.js constructor.<br />\n   * These can be overridden using the `options` argument of Popper.js.<br />\n   * To override an option, simply pass an object with the same\n   * structure of the `options` object, as the 3rd argument. For example:\n   * ```\n   * new Popper(ref, pop, {\n   *   modifiers: {\n   *     preventOverflow: { enabled: false }\n   *   }\n   * })\n   * ```\n   * @type {Object}\n   * @static\n   * @memberof Popper\n   */\n\n  var Defaults = {\n    /**\n     * Popper's placement.\n     * @prop {Popper.placements} placement='bottom'\n     */\n    placement: 'bottom',\n\n    /**\n     * Set this to true if you want popper to position it self in 'fixed' mode\n     * @prop {Boolean} positionFixed=false\n     */\n    positionFixed: false,\n\n    /**\n     * Whether events (resize, scroll) are initially enabled.\n     * @prop {Boolean} eventsEnabled=true\n     */\n    eventsEnabled: true,\n\n    /**\n     * Set to true if you want to automatically remove the popper when\n     * you call the `destroy` method.\n     * @prop {Boolean} removeOnDestroy=false\n     */\n    removeOnDestroy: false,\n\n    /**\n     * Callback called when the popper is created.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onCreate}\n     */\n    onCreate: function onCreate() {},\n\n    /**\n     * Callback called when the popper is updated. This callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onUpdate}\n     */\n    onUpdate: function onUpdate() {},\n\n    /**\n     * List of modifiers used to modify the offsets before they are applied to the popper.\n     * They provide most of the functionalities of Popper.js.\n     * @prop {modifiers}\n     */\n    modifiers: modifiers\n  };\n  /**\n   * @callback onCreate\n   * @param {dataObject} data\n   */\n\n  /**\n   * @callback onUpdate\n   * @param {dataObject} data\n   */\n  // Utils\n  // Methods\n\n  var Popper = function () {\n    /**\n     * Creates a new Popper.js instance.\n     * @class Popper\n     * @param {Element|referenceObject} reference - The reference element used to position the popper\n     * @param {Element} popper - The HTML / XML element used as the popper\n     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n     * @return {Object} instance - The generated Popper.js instance\n     */\n    function Popper(reference, popper) {\n      var _this = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      classCallCheck(this, Popper);\n\n      this.scheduleUpdate = function () {\n        return requestAnimationFrame(_this.update);\n      }; // make update() debounced, so that it only runs at most once-per-tick\n\n\n      this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it\n\n      this.options = _extends$1({}, Popper.Defaults, options); // init state\n\n      this.state = {\n        isDestroyed: false,\n        isCreated: false,\n        scrollParents: []\n      }; // get reference and popper elements (allow jQuery wrappers)\n\n      this.reference = reference && reference.jquery ? reference[0] : reference;\n      this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options\n\n      this.options.modifiers = {};\n      Object.keys(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n        _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n      }); // Refactoring modifiers' list (Object => Array)\n\n      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n        return _extends$1({\n          name: name\n        }, _this.options.modifiers[name]);\n      }) // sort the modifiers by order\n      .sort(function (a, b) {\n        return a.order - b.order;\n      }); // modifiers have the ability to execute arbitrary code when Popper.js get inited\n      // such code is executed in the same order of its modifier\n      // they could add new properties to their options configuration\n      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n\n      this.modifiers.forEach(function (modifierOptions) {\n        if (modifierOptions.enabled && isFunction$1(modifierOptions.onLoad)) {\n          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n        }\n      }); // fire the first update to position the popper in the right place\n\n      this.update();\n      var eventsEnabled = this.options.eventsEnabled;\n\n      if (eventsEnabled) {\n        // setup event listeners, they will take care of update the position in specific situations\n        this.enableEventListeners();\n      }\n\n      this.state.eventsEnabled = eventsEnabled;\n    } // We can't use class properties because they don't get listed in the\n    // class prototype and break stuff like Sinon stubs\n\n\n    createClass(Popper, [{\n      key: 'update',\n      value: function update$$1() {\n        return update.call(this);\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy$$1() {\n        return destroy.call(this);\n      }\n    }, {\n      key: 'enableEventListeners',\n      value: function enableEventListeners$$1() {\n        return enableEventListeners.call(this);\n      }\n    }, {\n      key: 'disableEventListeners',\n      value: function disableEventListeners$$1() {\n        return disableEventListeners.call(this);\n      }\n      /**\n       * Schedules an update. It will run on the next UI update available.\n       * @method scheduleUpdate\n       * @memberof Popper\n       */\n\n      /**\n       * Collection of utilities useful when writing custom modifiers.\n       * Starting from version 1.7, this method is available only if you\n       * include `popper-utils.js` before `popper.js`.\n       *\n       * **DEPRECATION**: This way to access PopperUtils is deprecated\n       * and will be removed in v2! Use the PopperUtils module directly instead.\n       * Due to the high instability of the methods contained in Utils, we can't\n       * guarantee them to follow semver. Use them at your own risk!\n       * @static\n       * @private\n       * @type {Object}\n       * @deprecated since version 1.8\n       * @member Utils\n       * @memberof Popper\n       */\n\n    }]);\n    return Popper;\n  }();\n  /**\n   * The `referenceObject` is an object that provides an interface compatible with Popper.js\n   * and lets you use it as replacement of a real DOM node.<br />\n   * You can use this method to position a popper relatively to a set of coordinates\n   * in case you don't have a DOM node to use as reference.\n   *\n   * ```\n   * new Popper(referenceObject, popperNode);\n   * ```\n   *\n   * NB: This feature isn't supported in Internet Explorer 10.\n   * @name referenceObject\n   * @property {Function} data.getBoundingClientRect\n   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n   * @property {number} data.clientWidth\n   * An ES6 getter that will return the width of the virtual reference element.\n   * @property {number} data.clientHeight\n   * An ES6 getter that will return the height of the virtual reference element.\n   */\n\n\n  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\n  Popper.placements = placements;\n  Popper.Defaults = Defaults;\n  /**!\n  * tippy.js v4.3.4\n  * (c) 2017-2019 atomiks\n  * MIT License\n  */\n\n  var css = \".tippy-iOS{cursor:pointer!important;-webkit-tap-highlight-color:transparent}.tippy-popper{transition-timing-function:cubic-bezier(.165,.84,.44,1);max-width:calc(100% - 8px);pointer-events:none;outline:0}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-7px;bottom:-6.5px;-webkit-transform-origin:50% 0;transform-origin:50% 0;margin:0 3px}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;bottom:-7px;margin:0 3px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 25%;transform-origin:0 25%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%)}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%,-45%);transform:scale(.2) translate(-50%,-45%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(-10px) rotateX(0);transform:perspective(700px) translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateY(0) rotateX(60deg);transform:perspective(700px) translateY(0) rotateX(60deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px) scale(.5);transform:translateY(-10px) scale(.5)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%;margin:0 3px}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(0);transform:rotate(0)}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:8px solid #333;border-right:8px solid transparent;border-left:8px solid transparent;top:-7px;margin:0 3px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%)}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-50%);transform:scale(.2) translate(-50%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateY(10px) rotateX(0);transform:perspective(700px) translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateY(0) rotateX(-60deg);transform:perspective(700px) translateY(0) rotateX(-60deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px) scale(.5);transform:translateY(10px) scale(.5)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-12px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%;margin:3px 0}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-75%,-50%);transform:scale(.2) translate(-75%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(-10px) rotateY(0);transform:perspective(700px) translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateX(0) rotateY(-60deg);transform:perspective(700px) translateX(0) rotateY(-60deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px) scale(.5);transform:translateX(-10px) scale(.5)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-12px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%;margin:3px 0}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:8px solid #333;border-top:8px solid transparent;border-bottom:8px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%)}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(.2) translate(-25%,-50%);transform:scale(.2) translate(-25%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{-webkit-transform:perspective(700px) translateX(10px) rotateY(0);transform:perspective(700px) translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:perspective(700px) translateX(0) rotateY(60deg);transform:perspective(700px) translateX(0) rotateY(60deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px) scale(.5);transform:translateX(10px) scale(.5)}.tippy-tooltip{position:relative;color:#fff;border-radius:.25rem;font-size:.875rem;padding:.3125rem .5625rem;line-height:1.4;text-align:center;background-color:#333}.tippy-tooltip[data-size=small]{padding:.1875rem .375rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.375rem .75rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] .tippy-roundarrow path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:18px;height:7px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;background-color:#333;border-radius:50%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:\\\"\\\";float:left;padding-top:100%}.tippy-backdrop+.tippy-content{transition-property:opacity;will-change:opacity}.tippy-backdrop+.tippy-content[data-state=visible]{opacity:1}.tippy-backdrop+.tippy-content[data-state=hidden]{opacity:0}\";\n\n  function _extends$2() {\n    _extends$2 = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends$2.apply(this, arguments);\n  }\n\n  var version = \"4.3.4\";\n  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined';\n  var ua = isBrowser$1 ? navigator.userAgent : '';\n  var isIE$1 = /MSIE |Trident\\//.test(ua);\n  var isUCBrowser = /UCBrowser\\//.test(ua);\n  var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;\n  var defaultProps = {\n    a11y: true,\n    allowHTML: true,\n    animateFill: true,\n    animation: 'shift-away',\n    appendTo: function appendTo() {\n      return document.body;\n    },\n    aria: 'describedby',\n    arrow: false,\n    arrowType: 'sharp',\n    boundary: 'scrollParent',\n    content: '',\n    delay: 0,\n    distance: 10,\n    duration: [325, 275],\n    flip: true,\n    flipBehavior: 'flip',\n    flipOnUpdate: false,\n    followCursor: false,\n    hideOnClick: true,\n    ignoreAttributes: false,\n    inertia: false,\n    interactive: false,\n    interactiveBorder: 2,\n    interactiveDebounce: 0,\n    lazy: true,\n    maxWidth: 350,\n    multiple: false,\n    offset: 0,\n    onHidden: function onHidden() {},\n    onHide: function onHide() {},\n    onMount: function onMount() {},\n    onShow: function onShow() {},\n    onShown: function onShown() {},\n    onTrigger: function onTrigger() {},\n    placement: 'top',\n    popperOptions: {},\n    role: 'tooltip',\n    showOnInit: false,\n    size: 'regular',\n    sticky: false,\n    target: '',\n    theme: 'dark',\n    touch: true,\n    touchHold: false,\n    trigger: 'mouseenter focus',\n    triggerTarget: null,\n    updateDuration: 0,\n    wait: null,\n    zIndex: 9999\n    /**\n     * If the set() method encounters one of these, the popperInstance must be\n     * recreated\n     */\n\n  };\n  var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];\n  var elementProto = isBrowser$1 ? Element.prototype : {};\n  var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;\n  /**\n   * Ponyfill for Array.from - converts iterable values to an array\n   */\n\n  function arrayFrom(value) {\n    return [].slice.call(value);\n  }\n  /**\n   * Ponyfill for Element.prototype.closest\n   */\n\n\n  function closest(element, selector) {\n    return closestCallback(element, function (el) {\n      return matches.call(el, selector);\n    });\n  }\n  /**\n   * Works like Element.prototype.closest, but uses a callback instead\n   */\n\n\n  function closestCallback(element, callback) {\n    while (element) {\n      if (callback(element)) {\n        return element;\n      }\n\n      element = element.parentElement;\n    }\n\n    return null;\n  } // Passive event listener config\n\n\n  var PASSIVE = {\n    passive: true // Popper `preventOverflow` padding\n\n  };\n  var PADDING = 4; // Popper attributes\n  // In Popper v2 these will be `data-*` instead of `x-*` to adhere to HTML5 spec\n\n  var PLACEMENT_ATTRIBUTE = 'x-placement';\n  var OUT_OF_BOUNDARIES_ATTRIBUTE = 'x-out-of-boundaries'; // Classes\n\n  var IOS_CLASS = \"tippy-iOS\";\n  var ACTIVE_CLASS = \"tippy-active\";\n  var POPPER_CLASS = \"tippy-popper\";\n  var TOOLTIP_CLASS = \"tippy-tooltip\";\n  var CONTENT_CLASS = \"tippy-content\";\n  var BACKDROP_CLASS = \"tippy-backdrop\";\n  var ARROW_CLASS = \"tippy-arrow\";\n  var ROUND_ARROW_CLASS = \"tippy-roundarrow\"; // Selectors\n\n  var POPPER_SELECTOR = \".\".concat(POPPER_CLASS);\n  var TOOLTIP_SELECTOR = \".\".concat(TOOLTIP_CLASS);\n  var CONTENT_SELECTOR = \".\".concat(CONTENT_CLASS);\n  var BACKDROP_SELECTOR = \".\".concat(BACKDROP_CLASS);\n  var ARROW_SELECTOR = \".\".concat(ARROW_CLASS);\n  var ROUND_ARROW_SELECTOR = \".\".concat(ROUND_ARROW_CLASS);\n  var isUsingTouch = false;\n\n  function onDocumentTouch() {\n    if (isUsingTouch) {\n      return;\n    }\n\n    isUsingTouch = true;\n\n    if (isIOS) {\n      document.body.classList.add(IOS_CLASS);\n    }\n\n    if (window.performance) {\n      document.addEventListener('mousemove', onDocumentMouseMove);\n    }\n  }\n\n  var lastMouseMoveTime = 0;\n\n  function onDocumentMouseMove() {\n    var now = performance.now(); // Chrome 60+ is 1 mousemove per animation frame, use 20ms time difference\n\n    if (now - lastMouseMoveTime < 20) {\n      isUsingTouch = false;\n      document.removeEventListener('mousemove', onDocumentMouseMove);\n\n      if (!isIOS) {\n        document.body.classList.remove(IOS_CLASS);\n      }\n    }\n\n    lastMouseMoveTime = now;\n  }\n\n  function onWindowBlur() {\n    var _document = document,\n        activeElement = _document.activeElement;\n\n    if (activeElement && activeElement.blur && activeElement._tippy) {\n      activeElement.blur();\n    }\n  }\n  /**\n   * Adds the needed global event listeners\n   */\n\n\n  function bindGlobalEventListeners() {\n    document.addEventListener('touchstart', onDocumentTouch, PASSIVE);\n    window.addEventListener('blur', onWindowBlur);\n  }\n\n  var keys = Object.keys(defaultProps);\n  /**\n   * Returns an object of optional props from data-tippy-* attributes\n   */\n\n  function getDataAttributeOptions(reference) {\n    return keys.reduce(function (acc, key) {\n      var valueAsString = (reference.getAttribute(\"data-tippy-\".concat(key)) || '').trim();\n\n      if (!valueAsString) {\n        return acc;\n      }\n\n      if (key === 'content') {\n        acc[key] = valueAsString;\n      } else {\n        try {\n          acc[key] = JSON.parse(valueAsString);\n        } catch (e) {\n          acc[key] = valueAsString;\n        }\n      }\n\n      return acc;\n    }, {});\n  }\n  /**\n   * Polyfills the virtual reference (plain object) with Element.prototype props\n   * Mutating because DOM elements are mutated, adds `_tippy` property\n   */\n\n\n  function polyfillElementPrototypeProperties(virtualReference) {\n    var polyfills = {\n      isVirtual: true,\n      attributes: virtualReference.attributes || {},\n      contains: function contains() {},\n      setAttribute: function setAttribute(key, value) {\n        virtualReference.attributes[key] = value;\n      },\n      getAttribute: function getAttribute(key) {\n        return virtualReference.attributes[key];\n      },\n      removeAttribute: function removeAttribute(key) {\n        delete virtualReference.attributes[key];\n      },\n      hasAttribute: function hasAttribute(key) {\n        return key in virtualReference.attributes;\n      },\n      addEventListener: function addEventListener() {},\n      removeEventListener: function removeEventListener() {},\n      classList: {\n        classNames: {},\n        add: function add(key) {\n          virtualReference.classList.classNames[key] = true;\n        },\n        remove: function remove(key) {\n          delete virtualReference.classList.classNames[key];\n        },\n        contains: function contains(key) {\n          return key in virtualReference.classList.classNames;\n        }\n      }\n    };\n\n    for (var key in polyfills) {\n      virtualReference[key] = polyfills[key];\n    }\n  }\n  /**\n   * Determines if a value is a \"bare\" virtual element (before mutations done\n   * by `polyfillElementPrototypeProperties()`). JSDOM elements show up as\n   * [object Object], we can check if the value is \"element-like\" if it has\n   * `addEventListener`\n   */\n\n\n  function isBareVirtualElement(value) {\n    return {}.toString.call(value) === '[object Object]' && !value.addEventListener;\n  }\n  /**\n   * Determines if the value is a reference element\n   */\n\n\n  function isReferenceElement(value) {\n    return !!value._tippy && !matches.call(value, POPPER_SELECTOR);\n  }\n  /**\n   * Safe .hasOwnProperty check, for prototype-less objects\n   */\n\n\n  function hasOwnProperty$1(obj, key) {\n    return {}.hasOwnProperty.call(obj, key);\n  }\n  /**\n   * Returns an array of elements based on the value\n   */\n\n\n  function getArrayOfElements(value) {\n    if (isSingular(value)) {\n      // TODO: VirtualReference is not compatible to type Element\n      return [value];\n    }\n\n    if (value instanceof NodeList) {\n      return arrayFrom(value);\n    }\n\n    if (Array.isArray(value)) {\n      return value;\n    }\n\n    try {\n      return arrayFrom(document.querySelectorAll(value));\n    } catch (e) {\n      return [];\n    }\n  }\n  /**\n   * Returns a value at a given index depending on if it's an array or number\n   */\n\n\n  function getValue(value, index, defaultValue) {\n    if (Array.isArray(value)) {\n      var v = value[index];\n      return v == null ? defaultValue : v;\n    }\n\n    return value;\n  }\n  /**\n   * Debounce utility. To avoid bloating bundle size, we're only passing 1\n   * argument here, a more generic function would pass all arguments. Only\n   * `onMouseMove` uses this which takes the event object for now.\n   */\n\n\n  function debounce$1(fn, ms) {\n    // Avoid wrapping in `setTimeout` if ms is 0 anyway\n    if (ms === 0) {\n      return fn;\n    }\n\n    var timeout;\n    return function (arg) {\n      clearTimeout(timeout);\n      timeout = setTimeout(function () {\n        fn(arg);\n      }, ms);\n    };\n  }\n  /**\n   * Prevents errors from being thrown while accessing nested modifier objects\n   * in `popperOptions`\n   */\n\n\n  function getModifier(obj, key) {\n    return obj && obj.modifiers && obj.modifiers[key];\n  }\n  /**\n   * Determines if an array or string includes a value\n   */\n\n\n  function includes(a, b) {\n    return a.indexOf(b) > -1;\n  }\n  /**\n   * Determines if the value is a real element\n   */\n\n\n  function isRealElement(value) {\n    return value instanceof Element;\n  }\n  /**\n   * Determines if the value is singular-like\n   */\n\n\n  function isSingular(value) {\n    return !!(value && hasOwnProperty$1(value, 'isVirtual')) || isRealElement(value);\n  }\n  /**\n   * Firefox extensions don't allow setting .innerHTML directly, this will trick it\n   */\n\n\n  function innerHTML() {\n    return 'innerHTML';\n  }\n  /**\n   * Evaluates a function if one, or returns the value\n   */\n\n\n  function invokeWithArgsOrReturn(value, args) {\n    return typeof value === 'function' ? value.apply(null, args) : value;\n  }\n  /**\n   * Sets a popperInstance `flip` modifier's enabled state\n   */\n\n\n  function setFlipModifierEnabled(modifiers, value) {\n    modifiers.filter(function (m) {\n      return m.name === 'flip';\n    })[0].enabled = value;\n  }\n  /**\n   * Determines if an element can receive focus\n   * Always returns true for virtual objects\n   */\n\n\n  function canReceiveFocus(element) {\n    return isRealElement(element) ? matches.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;\n  }\n  /**\n   * Returns a new `div` element\n   */\n\n\n  function div() {\n    return document.createElement('div');\n  }\n  /**\n   * Applies a transition duration to a list of elements\n   */\n\n\n  function setTransitionDuration(els, value) {\n    els.forEach(function (el) {\n      if (el) {\n        el.style.transitionDuration = \"\".concat(value, \"ms\");\n      }\n    });\n  }\n  /**\n   * Sets the visibility state to elements so they can begin to transition\n   */\n\n\n  function setVisibilityState(els, state) {\n    els.forEach(function (el) {\n      if (el) {\n        el.setAttribute('data-state', state);\n      }\n    });\n  }\n  /**\n   * Evaluates the props object by merging data attributes and\n   * disabling conflicting options where necessary\n   */\n\n\n  function evaluateProps(reference, props) {\n    var out = _extends$2({}, props, {\n      content: invokeWithArgsOrReturn(props.content, [reference])\n    }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));\n\n    if (out.arrow || isUCBrowser) {\n      out.animateFill = false;\n    }\n\n    return out;\n  }\n  /**\n   * Validates an object of options with the valid default props object\n   */\n\n\n  function validateOptions(options, defaultProps) {\n    Object.keys(options).forEach(function (option) {\n      if (!hasOwnProperty$1(defaultProps, option)) {\n        throw new Error(\"[tippy]: `\".concat(option, \"` is not a valid option\"));\n      }\n    });\n  }\n  /**\n   * Sets the innerHTML of an element\n   */\n\n\n  function setInnerHTML(element, html) {\n    element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;\n  }\n  /**\n   * Sets the content of a tooltip\n   */\n\n\n  function setContent(contentEl, props) {\n    if (isRealElement(props.content)) {\n      setInnerHTML(contentEl, '');\n      contentEl.appendChild(props.content);\n    } else if (typeof props.content !== 'function') {\n      var key = props.allowHTML ? 'innerHTML' : 'textContent';\n      contentEl[key] = props.content;\n    }\n  }\n  /**\n   * Returns the child elements of a popper element\n   */\n\n\n  function getChildren(popper) {\n    return {\n      tooltip: popper.querySelector(TOOLTIP_SELECTOR),\n      backdrop: popper.querySelector(BACKDROP_SELECTOR),\n      content: popper.querySelector(CONTENT_SELECTOR),\n      arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)\n    };\n  }\n  /**\n   * Adds `data-inertia` attribute\n   */\n\n\n  function addInertia(tooltip) {\n    tooltip.setAttribute('data-inertia', '');\n  }\n  /**\n   * Removes `data-inertia` attribute\n   */\n\n\n  function removeInertia(tooltip) {\n    tooltip.removeAttribute('data-inertia');\n  }\n  /**\n   * Creates an arrow element and returns it\n   */\n\n\n  function createArrowElement(arrowType) {\n    var arrow = div();\n\n    if (arrowType === 'round') {\n      arrow.className = ROUND_ARROW_CLASS;\n      setInnerHTML(arrow, '<svg viewBox=\"0 0 18 7\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z\"/></svg>');\n    } else {\n      arrow.className = ARROW_CLASS;\n    }\n\n    return arrow;\n  }\n  /**\n   * Creates a backdrop element and returns it\n   */\n\n\n  function createBackdropElement() {\n    var backdrop = div();\n    backdrop.className = BACKDROP_CLASS;\n    backdrop.setAttribute('data-state', 'hidden');\n    return backdrop;\n  }\n  /**\n   * Adds interactive-related attributes\n   */\n\n\n  function addInteractive(popper, tooltip) {\n    popper.setAttribute('tabindex', '-1');\n    tooltip.setAttribute('data-interactive', '');\n  }\n  /**\n   * Removes interactive-related attributes\n   */\n\n\n  function removeInteractive(popper, tooltip) {\n    popper.removeAttribute('tabindex');\n    tooltip.removeAttribute('data-interactive');\n  }\n  /**\n   * Add/remove transitionend listener from tooltip\n   */\n\n\n  function updateTransitionEndListener(tooltip, action, listener) {\n    // UC Browser hasn't adopted the `transitionend` event despite supporting\n    // unprefixed transitions...\n    var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';\n    tooltip[action + 'EventListener'](eventName, listener);\n  }\n  /**\n   * Returns the popper's placement, ignoring shifting (top-start, etc)\n   */\n\n\n  function getBasicPlacement(popper) {\n    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);\n    return fullPlacement ? fullPlacement.split('-')[0] : '';\n  }\n  /**\n   * Triggers reflow\n   */\n\n\n  function reflow(popper) {\n    void popper.offsetHeight;\n  }\n  /**\n   * Adds/removes theme from tooltip's classList\n   */\n\n\n  function updateTheme(tooltip, action, theme) {\n    theme.split(' ').forEach(function (themeName) {\n      tooltip.classList[action](themeName + '-theme');\n    });\n  }\n  /**\n   * Constructs the popper element and returns it\n   */\n\n\n  function createPopperElement(id, props) {\n    var popper = div();\n    popper.className = POPPER_CLASS;\n    popper.id = \"tippy-\".concat(id);\n    popper.style.zIndex = '' + props.zIndex;\n    popper.style.position = 'absolute';\n    popper.style.top = '0';\n    popper.style.left = '0';\n\n    if (props.role) {\n      popper.setAttribute('role', props.role);\n    }\n\n    var tooltip = div();\n    tooltip.className = TOOLTIP_CLASS;\n    tooltip.style.maxWidth = props.maxWidth + (typeof props.maxWidth === 'number' ? 'px' : '');\n    tooltip.setAttribute('data-size', props.size);\n    tooltip.setAttribute('data-animation', props.animation);\n    tooltip.setAttribute('data-state', 'hidden');\n    updateTheme(tooltip, 'add', props.theme);\n    var content = div();\n    content.className = CONTENT_CLASS;\n    content.setAttribute('data-state', 'hidden');\n\n    if (props.interactive) {\n      addInteractive(popper, tooltip);\n    }\n\n    if (props.arrow) {\n      tooltip.appendChild(createArrowElement(props.arrowType));\n    }\n\n    if (props.animateFill) {\n      tooltip.appendChild(createBackdropElement());\n      tooltip.setAttribute('data-animatefill', '');\n    }\n\n    if (props.inertia) {\n      addInertia(tooltip);\n    }\n\n    setContent(content, props);\n    tooltip.appendChild(content);\n    popper.appendChild(tooltip);\n    return popper;\n  }\n  /**\n   * Updates the popper element based on the new props\n   */\n\n\n  function updatePopperElement(popper, prevProps, nextProps) {\n    var _getChildren = getChildren(popper),\n        tooltip = _getChildren.tooltip,\n        content = _getChildren.content,\n        backdrop = _getChildren.backdrop,\n        arrow = _getChildren.arrow;\n\n    popper.style.zIndex = '' + nextProps.zIndex;\n    tooltip.setAttribute('data-size', nextProps.size);\n    tooltip.setAttribute('data-animation', nextProps.animation);\n    tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');\n\n    if (nextProps.role) {\n      popper.setAttribute('role', nextProps.role);\n    } else {\n      popper.removeAttribute('role');\n    }\n\n    if (prevProps.content !== nextProps.content) {\n      setContent(content, nextProps);\n    } // animateFill\n\n\n    if (!prevProps.animateFill && nextProps.animateFill) {\n      tooltip.appendChild(createBackdropElement());\n      tooltip.setAttribute('data-animatefill', '');\n    } else if (prevProps.animateFill && !nextProps.animateFill) {\n      tooltip.removeChild(backdrop);\n      tooltip.removeAttribute('data-animatefill');\n    } // arrow\n\n\n    if (!prevProps.arrow && nextProps.arrow) {\n      tooltip.appendChild(createArrowElement(nextProps.arrowType));\n    } else if (prevProps.arrow && !nextProps.arrow) {\n      tooltip.removeChild(arrow);\n    } // arrowType\n\n\n    if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {\n      tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);\n    } // interactive\n\n\n    if (!prevProps.interactive && nextProps.interactive) {\n      addInteractive(popper, tooltip);\n    } else if (prevProps.interactive && !nextProps.interactive) {\n      removeInteractive(popper, tooltip);\n    } // inertia\n\n\n    if (!prevProps.inertia && nextProps.inertia) {\n      addInertia(tooltip);\n    } else if (prevProps.inertia && !nextProps.inertia) {\n      removeInertia(tooltip);\n    } // theme\n\n\n    if (prevProps.theme !== nextProps.theme) {\n      updateTheme(tooltip, 'remove', prevProps.theme);\n      updateTheme(tooltip, 'add', nextProps.theme);\n    }\n  }\n  /**\n   * Hides all visible poppers on the document\n   */\n\n\n  function hideAll() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        excludedReferenceOrInstance = _ref.exclude,\n        duration = _ref.duration;\n\n    arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {\n      var instance = popper._tippy;\n\n      if (instance) {\n        var isExcluded = false;\n\n        if (excludedReferenceOrInstance) {\n          isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;\n        }\n\n        if (!isExcluded) {\n          instance.hide(duration);\n        }\n      }\n    });\n  }\n  /**\n   * Determines if the mouse cursor is outside of the popper's interactive border\n   * region\n   */\n\n\n  function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {\n    if (!popperPlacement) {\n      return true;\n    }\n\n    var x = event.clientX,\n        y = event.clientY;\n    var interactiveBorder = props.interactiveBorder,\n        distance = props.distance;\n    var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);\n    var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);\n    var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);\n    var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);\n    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n  }\n  /**\n   * Returns the distance offset, taking into account the default offset due to\n   * the transform: translate() rule (10px) in CSS\n   */\n\n\n  function getOffsetDistanceInPx(distance) {\n    return -(distance - 10) + 'px';\n  }\n\n  var idCounter = 1; // Workaround for IE11's lack of new MouseEvent constructor\n\n  var mouseMoveListeners = [];\n  /**\n   * Creates and returns a Tippy object. We're using a closure pattern instead of\n   * a class so that the exposed object API is clean without private members\n   * prefixed with `_`.\n   */\n\n  function createTippy(reference, collectionProps) {\n    var props = evaluateProps(reference, collectionProps); // If the reference shouldn't have multiple tippys, return null early\n\n    if (!props.multiple && reference._tippy) {\n      return null;\n    }\n    /* ======================= 🔒 Private members 🔒 ======================= */\n\n\n    var lastTriggerEventType;\n    var lastMouseMoveEvent;\n    var showTimeoutId;\n    var hideTimeoutId;\n    var scheduleHideAnimationFrameId;\n    var isScheduledToShow = false;\n    var isBeingDestroyed = false;\n    var previousPlacement;\n    var wasVisibleDuringPreviousUpdate = false;\n    var hasMountCallbackRun = false;\n    var currentMountCallback;\n    var currentTransitionEndListener;\n    var listeners = [];\n    var currentComputedPadding;\n    var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);\n    /* ======================= 🔑 Public members 🔑 ======================= */\n\n    var id = idCounter++;\n    var popper = createPopperElement(id, props);\n    var popperChildren = getChildren(popper);\n    var popperInstance = null;\n    var state = {\n      // Is the instance currently enabled?\n      isEnabled: true,\n      // Is the tippy currently showing and not transitioning out?\n      isVisible: false,\n      // Has the instance been destroyed?\n      isDestroyed: false,\n      // Is the tippy currently mounted to the DOM?\n      isMounted: false,\n      // Has the tippy finished transitioning in?\n      isShown: false\n    };\n    var instance = {\n      // properties\n      id: id,\n      reference: reference,\n      popper: popper,\n      popperChildren: popperChildren,\n      popperInstance: popperInstance,\n      props: props,\n      state: state,\n      // methods\n      clearDelayTimeouts: clearDelayTimeouts,\n      set: set,\n      setContent: setContent,\n      show: show,\n      hide: hide,\n      enable: enable,\n      disable: disable,\n      destroy: destroy\n      /* ==================== Initial instance mutations =================== */\n\n    };\n    reference._tippy = instance;\n    popper._tippy = instance;\n    addTriggersToReference();\n\n    if (!props.lazy) {\n      createPopperInstance();\n    }\n\n    if (props.showOnInit) {\n      scheduleShow();\n    } // Ensure the event listeners target can receive focus\n\n\n    if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {\n      getEventListenersTarget().setAttribute('tabindex', '0');\n    } // Prevent a tippy with a delay from hiding if the cursor left then returned\n    // before it started hiding\n\n\n    popper.addEventListener('mouseenter', function (event) {\n      if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {\n        // We don't want props.onTrigger() to be called here, since the `event`\n        // object is not related to the reference element\n        scheduleShow(event, true);\n      }\n    });\n    popper.addEventListener('mouseleave', function () {\n      if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {\n        document.addEventListener('mousemove', debouncedOnMouseMove);\n      }\n    });\n    return instance;\n    /* ======================= 🔒 Private methods 🔒 ======================= */\n\n    /**\n     * Removes the follow cursor listener\n     */\n\n    function removeFollowCursorListener() {\n      document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);\n    }\n    /**\n     * Cleans up interactive mouse listeners\n     */\n\n\n    function cleanupInteractiveMouseListeners() {\n      document.body.removeEventListener('mouseleave', scheduleHide);\n      document.removeEventListener('mousemove', debouncedOnMouseMove);\n      mouseMoveListeners = mouseMoveListeners.filter(function (listener) {\n        return listener !== debouncedOnMouseMove;\n      });\n    }\n    /**\n     * Returns correct target used for event listeners\n     */\n\n\n    function getEventListenersTarget() {\n      return instance.props.triggerTarget || reference;\n    }\n    /**\n     * Adds the document click event listener for the instance\n     */\n\n\n    function addDocumentClickListener() {\n      document.addEventListener('click', onDocumentClick, true);\n    }\n    /**\n     * Removes the document click event listener for the instance\n     */\n\n\n    function removeDocumentClickListener() {\n      document.removeEventListener('click', onDocumentClick, true);\n    }\n    /**\n     * Returns transitionable inner elements used in show/hide methods\n     */\n\n\n    function getTransitionableElements() {\n      return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];\n    }\n    /**\n     * Determines if the instance is in `followCursor` mode.\n     * NOTE: in v5, touch devices will use `initial` behavior no matter the value.\n     */\n\n\n    function getIsInLooseFollowCursorMode() {\n      var followCursor = instance.props.followCursor;\n      return followCursor && lastTriggerEventType !== 'focus' || isUsingTouch && followCursor === 'initial';\n    }\n    /**\n     * Updates the tooltip's position on each animation frame\n     */\n\n\n    function makeSticky() {\n      setTransitionDuration([popper], isIE$1 ? 0 : instance.props.updateDuration);\n\n      function updatePosition() {\n        instance.popperInstance.scheduleUpdate();\n\n        if (instance.state.isMounted) {\n          requestAnimationFrame(updatePosition);\n        } else {\n          setTransitionDuration([popper], 0);\n        }\n      }\n\n      updatePosition();\n    }\n    /**\n     * Invokes a callback once the tooltip has fully transitioned out\n     */\n\n\n    function onTransitionedOut(duration, callback) {\n      onTransitionEnd(duration, function () {\n        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {\n          callback();\n        }\n      });\n    }\n    /**\n     * Invokes a callback once the tooltip has fully transitioned in\n     */\n\n\n    function onTransitionedIn(duration, callback) {\n      onTransitionEnd(duration, callback);\n    }\n    /**\n     * Invokes a callback once the tooltip's CSS transition ends\n     */\n\n\n    function onTransitionEnd(duration, callback) {\n      var tooltip = instance.popperChildren.tooltip;\n      /**\n       * Listener added as the `transitionend` handler\n       */\n\n      function listener(event) {\n        if (event.target === tooltip) {\n          updateTransitionEndListener(tooltip, 'remove', listener);\n          callback();\n        }\n      } // Make callback synchronous if duration is 0\n      // `transitionend` won't fire otherwise\n\n\n      if (duration === 0) {\n        return callback();\n      }\n\n      updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);\n      updateTransitionEndListener(tooltip, 'add', listener);\n      currentTransitionEndListener = listener;\n    }\n    /**\n     * Adds an event listener to the reference and stores it in `listeners`\n     */\n\n\n    function on(eventType, handler) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      getEventListenersTarget().addEventListener(eventType, handler, options);\n      listeners.push({\n        eventType: eventType,\n        handler: handler,\n        options: options\n      });\n    }\n    /**\n     * Adds event listeners to the reference based on the `trigger` prop\n     */\n\n\n    function addTriggersToReference() {\n      if (instance.props.touchHold && !instance.props.target) {\n        on('touchstart', onTrigger, PASSIVE);\n        on('touchend', onMouseLeave, PASSIVE);\n      }\n\n      instance.props.trigger.trim().split(' ').forEach(function (eventType) {\n        if (eventType === 'manual') {\n          return;\n        } // Non-delegates\n\n\n        if (!instance.props.target) {\n          on(eventType, onTrigger);\n\n          switch (eventType) {\n            case 'mouseenter':\n              on('mouseleave', onMouseLeave);\n              break;\n\n            case 'focus':\n              on(isIE$1 ? 'focusout' : 'blur', onBlur);\n              break;\n          }\n        } else {\n          // Delegates\n          switch (eventType) {\n            case 'mouseenter':\n              on('mouseover', onDelegateShow);\n              on('mouseout', onDelegateHide);\n              break;\n\n            case 'focus':\n              on('focusin', onDelegateShow);\n              on('focusout', onDelegateHide);\n              break;\n\n            case 'click':\n              on(eventType, onDelegateShow);\n              break;\n          }\n        }\n      });\n    }\n    /**\n     * Removes event listeners from the reference\n     */\n\n\n    function removeTriggersFromReference() {\n      listeners.forEach(function (_ref) {\n        var eventType = _ref.eventType,\n            handler = _ref.handler,\n            options = _ref.options;\n        getEventListenersTarget().removeEventListener(eventType, handler, options);\n      });\n      listeners = [];\n    }\n    /**\n     * Positions the virtual reference near the cursor\n     */\n\n\n    function positionVirtualReferenceNearCursor(event) {\n      var _lastMouseMoveEvent = lastMouseMoveEvent = event,\n          x = _lastMouseMoveEvent.clientX,\n          y = _lastMouseMoveEvent.clientY; // Gets set once popperInstance `onCreate` has been called\n\n\n      if (!currentComputedPadding) {\n        return;\n      } // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n\n\n      var isCursorOverReference = closestCallback(event.target, function (el) {\n        return el === reference;\n      });\n      var rect = reference.getBoundingClientRect();\n      var followCursor = instance.props.followCursor;\n      var isHorizontal = followCursor === 'horizontal';\n      var isVertical = followCursor === 'vertical'; // The virtual reference needs some size to prevent itself from overflowing\n\n      var isVerticalPlacement = includes(['top', 'bottom'], getBasicPlacement(popper));\n      var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);\n      var isVariation = fullPlacement ? !!fullPlacement.split('-')[1] : false;\n      var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;\n      var halfSize = size / 2;\n      var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;\n      var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        instance.popperInstance.reference = _extends$2({}, instance.popperInstance.reference, {\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect: function getBoundingClientRect() {\n            return {\n              width: isVerticalPlacement ? size : 0,\n              height: isVerticalPlacement ? 0 : size,\n              top: (isHorizontal ? rect.top : y) - verticalIncrease,\n              bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,\n              left: (isVertical ? rect.left : x) - horizontalIncrease,\n              right: (isVertical ? rect.right : x) + horizontalIncrease\n            };\n          }\n        });\n        instance.popperInstance.update();\n      }\n\n      if (followCursor === 'initial' && instance.state.isVisible) {\n        removeFollowCursorListener();\n      }\n    }\n    /**\n     * Creates the tippy instance for a delegate when it's been triggered\n     */\n\n\n    function createDelegateChildTippy(event) {\n      if (event) {\n        var targetEl = closest(event.target, instance.props.target);\n\n        if (targetEl && !targetEl._tippy) {\n          createTippy(targetEl, _extends$2({}, instance.props, {\n            content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),\n            appendTo: collectionProps.appendTo,\n            target: '',\n            showOnInit: true\n          }));\n        }\n      }\n    }\n    /**\n     * Event listener invoked upon trigger\n     */\n\n\n    function onTrigger(event) {\n      if (!instance.state.isEnabled || isEventListenerStopped(event)) {\n        return;\n      }\n\n      if (!instance.state.isVisible) {\n        lastTriggerEventType = event.type;\n\n        if (event instanceof MouseEvent) {\n          lastMouseMoveEvent = event; // If scrolling, `mouseenter` events can be fired if the cursor lands\n          // over a new target, but `mousemove` events don't get fired. This\n          // causes interactive tooltips to get stuck open until the cursor is\n          // moved\n\n          mouseMoveListeners.forEach(function (listener) {\n            return listener(event);\n          });\n        }\n      } // Toggle show/hide when clicking click-triggered tooltips\n\n\n      if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {\n        scheduleHide();\n      } else {\n        scheduleShow(event);\n      }\n    }\n    /**\n     * Event listener used for interactive tooltips to detect when they should\n     * hide\n     */\n\n\n    function onMouseMove(event) {\n      var isCursorOverPopper = closest(event.target, POPPER_SELECTOR) === popper;\n      var isCursorOverReference = closestCallback(event.target, function (el) {\n        return el === reference;\n      });\n\n      if (isCursorOverPopper || isCursorOverReference) {\n        return;\n      }\n\n      if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {\n        cleanupInteractiveMouseListeners();\n        scheduleHide();\n      }\n    }\n    /**\n     * Event listener invoked upon mouseleave\n     */\n\n\n    function onMouseLeave(event) {\n      if (isEventListenerStopped(event)) {\n        return;\n      }\n\n      if (instance.props.interactive) {\n        document.body.addEventListener('mouseleave', scheduleHide);\n        document.addEventListener('mousemove', debouncedOnMouseMove);\n        mouseMoveListeners.push(debouncedOnMouseMove);\n        return;\n      }\n\n      scheduleHide();\n    }\n    /**\n     * Event listener invoked upon blur\n     */\n\n\n    function onBlur(event) {\n      if (event.target !== getEventListenersTarget()) {\n        return;\n      }\n\n      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {\n        return;\n      }\n\n      scheduleHide();\n    }\n    /**\n     * Event listener invoked when a child target is triggered\n     */\n\n\n    function onDelegateShow(event) {\n      if (closest(event.target, instance.props.target)) {\n        scheduleShow(event);\n      }\n    }\n    /**\n     * Event listener invoked when a child target should hide\n     */\n\n\n    function onDelegateHide(event) {\n      if (closest(event.target, instance.props.target)) {\n        scheduleHide();\n      }\n    }\n    /**\n     * Determines if an event listener should stop further execution due to the\n     * `touchHold` option\n     */\n\n\n    function isEventListenerStopped(event) {\n      var supportsTouch = 'ontouchstart' in window;\n      var isTouchEvent = includes(event.type, 'touch');\n      var touchHold = instance.props.touchHold;\n      return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;\n    }\n    /**\n     * Runs the mount callback\n     */\n\n\n    function runMountCallback() {\n      if (!hasMountCallbackRun && currentMountCallback) {\n        hasMountCallbackRun = true;\n        reflow(popper);\n        currentMountCallback();\n      }\n    }\n    /**\n     * Creates the popper instance for the instance\n     */\n\n\n    function createPopperInstance() {\n      var popperOptions = instance.props.popperOptions;\n      var _instance$popperChild = instance.popperChildren,\n          tooltip = _instance$popperChild.tooltip,\n          arrow = _instance$popperChild.arrow;\n      var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');\n\n      function applyMutations(data) {\n        if (instance.props.flip && !instance.props.flipOnUpdate) {\n          if (data.flipped) {\n            instance.popperInstance.options.placement = data.placement;\n          }\n\n          setFlipModifierEnabled(instance.popperInstance.modifiers, false);\n        } // Apply all of the popper's attributes to the tootip node as well.\n        // Allows users to avoid using the .tippy-popper selector for themes.\n\n\n        tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data.placement);\n\n        if (data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {\n          tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, '');\n        } else {\n          tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);\n        } // Prevents a transition when changing placements (while tippy is visible)\n        // for scroll/resize updates\n\n\n        if (previousPlacement && previousPlacement !== data.placement && wasVisibleDuringPreviousUpdate) {\n          tooltip.style.transition = 'none';\n          requestAnimationFrame(function () {\n            tooltip.style.transition = '';\n          });\n        }\n\n        previousPlacement = data.placement;\n        wasVisibleDuringPreviousUpdate = instance.state.isVisible;\n        var basicPlacement = getBasicPlacement(popper);\n        var styles = tooltip.style; // Account for the `distance` offset\n\n        styles.top = styles.bottom = styles.left = styles.right = '';\n        styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);\n        var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;\n        var isPaddingNumber = typeof padding === 'number';\n\n        var computedPadding = _extends$2({\n          top: isPaddingNumber ? padding : padding.top,\n          bottom: isPaddingNumber ? padding : padding.bottom,\n          left: isPaddingNumber ? padding : padding.left,\n          right: isPaddingNumber ? padding : padding.right\n        }, !isPaddingNumber && padding);\n\n        computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;\n        instance.popperInstance.modifiers.filter(function (m) {\n          return m.name === 'preventOverflow';\n        })[0].padding = computedPadding;\n        currentComputedPadding = computedPadding;\n      }\n\n      var config = _extends$2({\n        eventsEnabled: false,\n        placement: instance.props.placement\n      }, popperOptions, {\n        modifiers: _extends$2({}, popperOptions ? popperOptions.modifiers : {}, {\n          preventOverflow: _extends$2({\n            boundariesElement: instance.props.boundary,\n            padding: PADDING\n          }, preventOverflowModifier),\n          arrow: _extends$2({\n            element: arrow,\n            enabled: !!arrow\n          }, getModifier(popperOptions, 'arrow')),\n          flip: _extends$2({\n            enabled: instance.props.flip,\n            // The tooltip is offset by 10px from the popper in CSS,\n            // we need to account for its distance\n            padding: instance.props.distance + PADDING,\n            behavior: instance.props.flipBehavior\n          }, getModifier(popperOptions, 'flip')),\n          offset: _extends$2({\n            offset: instance.props.offset\n          }, getModifier(popperOptions, 'offset'))\n        }),\n        onCreate: function onCreate(data) {\n          applyMutations(data);\n          runMountCallback();\n\n          if (popperOptions && popperOptions.onCreate) {\n            popperOptions.onCreate(data);\n          }\n        },\n        onUpdate: function onUpdate(data) {\n          applyMutations(data);\n          runMountCallback();\n\n          if (popperOptions && popperOptions.onUpdate) {\n            popperOptions.onUpdate(data);\n          }\n        }\n      });\n\n      instance.popperInstance = new Popper(reference, popper, config);\n    }\n    /**\n     * Mounts the tooltip to the DOM\n     */\n\n\n    function mount() {\n      hasMountCallbackRun = false;\n      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();\n\n      if (instance.popperInstance) {\n        setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);\n\n        if (!isInLooseFollowCursorMode) {\n          instance.popperInstance.reference = reference;\n          instance.popperInstance.enableEventListeners();\n        }\n\n        instance.popperInstance.scheduleUpdate();\n      } else {\n        createPopperInstance();\n\n        if (!isInLooseFollowCursorMode) {\n          instance.popperInstance.enableEventListeners();\n        }\n      }\n\n      var appendTo = instance.props.appendTo;\n      var parentNode = appendTo === 'parent' ? reference.parentNode : invokeWithArgsOrReturn(appendTo, [reference]);\n\n      if (!parentNode.contains(popper)) {\n        parentNode.appendChild(popper);\n        instance.props.onMount(instance);\n        instance.state.isMounted = true;\n      }\n    }\n    /**\n     * Setup before show() is invoked (delays, etc.)\n     */\n\n\n    function scheduleShow(event, shouldAvoidCallingOnTrigger) {\n      clearDelayTimeouts();\n\n      if (instance.state.isVisible) {\n        return;\n      } // Is a delegate, create an instance for the child target\n\n\n      if (instance.props.target) {\n        return createDelegateChildTippy(event);\n      }\n\n      isScheduledToShow = true;\n\n      if (event && !shouldAvoidCallingOnTrigger) {\n        instance.props.onTrigger(instance, event);\n      }\n\n      if (instance.props.wait) {\n        return instance.props.wait(instance, event);\n      } // If the tooltip has a delay, we need to be listening to the mousemove as\n      // soon as the trigger event is fired, so that it's in the correct position\n      // upon mount.\n      // Edge case: if the tooltip is still mounted, but then scheduleShow() is\n      // called, it causes a jump.\n\n\n      if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {\n        if (!instance.popperInstance) {\n          createPopperInstance();\n        }\n\n        document.addEventListener('mousemove', positionVirtualReferenceNearCursor);\n      }\n\n      addDocumentClickListener();\n      var delay = getValue(instance.props.delay, 0, defaultProps.delay);\n\n      if (delay) {\n        showTimeoutId = setTimeout(function () {\n          show();\n        }, delay);\n      } else {\n        show();\n      }\n    }\n    /**\n     * Setup before hide() is invoked (delays, etc.)\n     */\n\n\n    function scheduleHide() {\n      clearDelayTimeouts();\n\n      if (!instance.state.isVisible) {\n        return removeFollowCursorListener();\n      }\n\n      isScheduledToShow = false;\n      var delay = getValue(instance.props.delay, 1, defaultProps.delay);\n\n      if (delay) {\n        hideTimeoutId = setTimeout(function () {\n          if (instance.state.isVisible) {\n            hide();\n          }\n        }, delay);\n      } else {\n        // Fixes a `transitionend` problem when it fires 1 frame too\n        // late sometimes, we don't want hide() to be called.\n        scheduleHideAnimationFrameId = requestAnimationFrame(function () {\n          hide();\n        });\n      }\n    }\n    /**\n     * Listener to handle clicks on the document to determine if the\n     * instance should hide\n     */\n\n\n    function onDocumentClick(event) {\n      // Clicked on interactive popper\n      if (instance.props.interactive && popper.contains(event.target)) {\n        return;\n      } // Clicked on the event listeners target\n\n\n      if (getEventListenersTarget().contains(event.target)) {\n        if (isUsingTouch) {\n          return;\n        }\n\n        if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {\n          return;\n        }\n      }\n\n      if (instance.props.hideOnClick === true) {\n        clearDelayTimeouts();\n        hide();\n      }\n    }\n    /* ======================= 🔑 Public methods 🔑 ======================= */\n\n    /**\n     * Enables the instance to allow it to show or hide\n     */\n\n\n    function enable() {\n      instance.state.isEnabled = true;\n    }\n    /**\n     * Disables the instance to disallow it to show or hide\n     */\n\n\n    function disable() {\n      instance.state.isEnabled = false;\n    }\n    /**\n     * Clears pending timeouts related to the `delay` prop if any\n     */\n\n\n    function clearDelayTimeouts() {\n      clearTimeout(showTimeoutId);\n      clearTimeout(hideTimeoutId);\n      cancelAnimationFrame(scheduleHideAnimationFrameId);\n    }\n    /**\n     * Sets new props for the instance and redraws the tooltip\n     */\n\n\n    function set(options) {\n      // Backwards-compatible after TypeScript change\n      options = options || {};\n      validateOptions(options, defaultProps);\n      removeTriggersFromReference();\n      var prevProps = instance.props;\n      var nextProps = evaluateProps(reference, _extends$2({}, instance.props, options, {\n        ignoreAttributes: true\n      }));\n      nextProps.ignoreAttributes = hasOwnProperty$1(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;\n      instance.props = nextProps;\n      addTriggersToReference();\n      cleanupInteractiveMouseListeners();\n      debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);\n      updatePopperElement(popper, prevProps, nextProps);\n      instance.popperChildren = getChildren(popper);\n\n      if (instance.popperInstance) {\n        if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {\n          return hasOwnProperty$1(options, prop) && options[prop] !== prevProps[prop];\n        })) {\n          instance.popperInstance.destroy();\n          createPopperInstance();\n\n          if (instance.state.isVisible) {\n            instance.popperInstance.enableEventListeners();\n          }\n\n          if (instance.props.followCursor && lastMouseMoveEvent) {\n            positionVirtualReferenceNearCursor(lastMouseMoveEvent);\n          }\n        } else {\n          instance.popperInstance.update();\n        }\n      }\n    }\n    /**\n     * Shortcut for .set({ content: newContent })\n     */\n\n\n    function setContent(content) {\n      set({\n        content: content\n      });\n    }\n    /**\n     * Shows the tooltip\n     */\n\n\n    function show() {\n      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);\n\n      if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {\n        return;\n      } // Standardize `disabled` behavior across browsers.\n      // Firefox allows events on disabled elements, but Chrome doesn't.\n      // Using a wrapper element (i.e. <span>) is recommended.\n\n\n      if (getEventListenersTarget().hasAttribute('disabled')) {\n        return;\n      }\n\n      if (instance.props.onShow(instance) === false) {\n        return;\n      }\n\n      addDocumentClickListener();\n      popper.style.visibility = 'visible';\n      instance.state.isVisible = true;\n\n      if (instance.props.interactive) {\n        getEventListenersTarget().classList.add(ACTIVE_CLASS);\n      } // Prevent a transition if the popper is at the opposite placement\n\n\n      var transitionableElements = getTransitionableElements();\n      setTransitionDuration(transitionableElements.concat(popper), 0);\n\n      currentMountCallback = function currentMountCallback() {\n        if (!instance.state.isVisible) {\n          return;\n        }\n\n        var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();\n\n        if (isInLooseFollowCursorMode && lastMouseMoveEvent) {\n          positionVirtualReferenceNearCursor(lastMouseMoveEvent);\n        } else if (!isInLooseFollowCursorMode) {\n          // Double update will apply correct mutations\n          instance.popperInstance.update();\n        }\n\n        if (instance.popperChildren.backdrop) {\n          instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';\n        }\n\n        if (instance.props.sticky) {\n          makeSticky();\n        }\n\n        setTransitionDuration([popper], instance.props.updateDuration);\n        setTransitionDuration(transitionableElements, duration);\n        setVisibilityState(transitionableElements, 'visible');\n        onTransitionedIn(duration, function () {\n          if (instance.props.aria) {\n            getEventListenersTarget().setAttribute(\"aria-\".concat(instance.props.aria), popper.id);\n          }\n\n          instance.props.onShown(instance);\n          instance.state.isShown = true;\n        });\n      };\n\n      mount();\n    }\n    /**\n     * Hides the tooltip\n     */\n\n\n    function hide() {\n      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);\n\n      if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {\n        return;\n      }\n\n      if (instance.props.onHide(instance) === false && !isBeingDestroyed) {\n        return;\n      }\n\n      removeDocumentClickListener();\n      popper.style.visibility = 'hidden';\n      instance.state.isVisible = false;\n      instance.state.isShown = false;\n      wasVisibleDuringPreviousUpdate = false;\n\n      if (instance.props.interactive) {\n        getEventListenersTarget().classList.remove(ACTIVE_CLASS);\n      }\n\n      var transitionableElements = getTransitionableElements();\n      setTransitionDuration(transitionableElements, duration);\n      setVisibilityState(transitionableElements, 'hidden');\n      onTransitionedOut(duration, function () {\n        if (!isScheduledToShow) {\n          removeFollowCursorListener();\n        }\n\n        if (instance.props.aria) {\n          getEventListenersTarget().removeAttribute(\"aria-\".concat(instance.props.aria));\n        }\n\n        instance.popperInstance.disableEventListeners();\n        instance.popperInstance.options.placement = instance.props.placement;\n        popper.parentNode.removeChild(popper);\n        instance.props.onHidden(instance);\n        instance.state.isMounted = false;\n      });\n    }\n    /**\n     * Destroys the tooltip\n     */\n\n\n    function destroy(destroyTargetInstances) {\n      if (instance.state.isDestroyed) {\n        return;\n      }\n\n      isBeingDestroyed = true; // If the popper is currently mounted to the DOM, we want to ensure it gets\n      // hidden and unmounted instantly upon destruction\n\n      if (instance.state.isMounted) {\n        hide(0);\n      }\n\n      removeTriggersFromReference();\n      delete reference._tippy;\n      var target = instance.props.target;\n\n      if (target && destroyTargetInstances && isRealElement(reference)) {\n        arrayFrom(reference.querySelectorAll(target)).forEach(function (child) {\n          if (child._tippy) {\n            child._tippy.destroy();\n          }\n        });\n      }\n\n      if (instance.popperInstance) {\n        instance.popperInstance.destroy();\n      }\n\n      isBeingDestroyed = false;\n      instance.state.isDestroyed = true;\n    }\n  }\n  /**\n   * Groups an array of instances by taking control of their props during\n   * certain lifecycles.\n   */\n\n\n  function group(instances) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === void 0 ? 0 : _ref$duration;\n\n    var isAnyTippyOpen = false;\n    instances.forEach(function (instance) {\n      if (instance._originalProps) {\n        instance.set(instance._originalProps);\n      } else {\n        instance._originalProps = _extends$2({}, instance.props);\n      }\n    });\n\n    function setIsAnyTippyOpen(value) {\n      isAnyTippyOpen = value;\n      updateInstances();\n    }\n\n    function onShow(instance) {\n      instance._originalProps.onShow(instance);\n\n      instances.forEach(function (instance) {\n        instance.set({\n          duration: duration\n        });\n\n        if (instance.state.isVisible) {\n          instance.hide();\n        }\n      });\n      setIsAnyTippyOpen(true);\n    }\n\n    function onHide(instance) {\n      instance._originalProps.onHide(instance);\n\n      setIsAnyTippyOpen(false);\n    }\n\n    function onShown(instance) {\n      instance._originalProps.onShown(instance);\n\n      instance.set({\n        duration: instance._originalProps.duration\n      });\n    }\n\n    function updateInstances() {\n      instances.forEach(function (instance) {\n        instance.set({\n          onShow: onShow,\n          onShown: onShown,\n          onHide: onHide,\n          delay: isAnyTippyOpen ? [0, Array.isArray(delay) ? delay[1] : delay] : delay,\n          duration: isAnyTippyOpen ? duration : instance._originalProps.duration\n        });\n      });\n    }\n\n    updateInstances();\n  }\n\n  var globalEventListenersBound = false;\n  /**\n   * Exported module\n   */\n\n  function tippy(targets, options) {\n    validateOptions(options || {}, defaultProps);\n\n    if (!globalEventListenersBound) {\n      bindGlobalEventListeners();\n      globalEventListenersBound = true;\n    }\n\n    var props = _extends$2({}, defaultProps, options); // If they are specifying a virtual positioning reference, we need to polyfill\n    // some native DOM props\n\n\n    if (isBareVirtualElement(targets)) {\n      polyfillElementPrototypeProperties(targets);\n    }\n\n    var instances = getArrayOfElements(targets).reduce(function (acc, reference) {\n      var instance = reference && createTippy(reference, props);\n\n      if (instance) {\n        acc.push(instance);\n      }\n\n      return acc;\n    }, []);\n    return isSingular(targets) ? instances[0] : instances;\n  }\n  /**\n   * Static props\n   */\n\n\n  tippy.version = version;\n  tippy.defaults = defaultProps;\n  /**\n   * Static methods\n   */\n\n  tippy.setDefaults = function (partialDefaults) {\n    Object.keys(partialDefaults).forEach(function (key) {\n      // @ts-ignore\n      defaultProps[key] = partialDefaults[key];\n    });\n  };\n\n  tippy.hideAll = hideAll;\n  tippy.group = group;\n  /**\n   * Auto-init tooltips for elements with a `data-tippy=\"...\"` attribute\n   */\n\n  function autoInit() {\n    arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {\n      var content = el.getAttribute('data-tippy');\n\n      if (content) {\n        tippy(el, {\n          content: content\n        });\n      }\n    });\n  }\n\n  if (isBrowser$1) {\n    setTimeout(autoInit);\n  }\n  /**\n   * Injects a string of CSS styles to a style node in <head>\n   */\n\n\n  function injectCSS(css) {\n    if (isBrowser$1) {\n      var style = document.createElement('style');\n      style.type = 'text/css';\n      style.textContent = css;\n      style.setAttribute('data-tippy-stylesheet', '');\n      var head = document.head;\n      var firstChild = head.firstChild;\n\n      if (firstChild) {\n        head.insertBefore(style, firstChild);\n      } else {\n        head.appendChild(style);\n      }\n    }\n  }\n\n  injectCSS(css);\n  var missingTippy = 'Using the attachment feature of Shepherd requires the Tippy.js library';\n  var addShepherdClass = {\n    enabled: true,\n    fn: function fn(data) {\n      data.instance.popper.classList.add('shepherd-popper');\n      return data;\n    }\n  };\n  var centeredStylePopperModifier = {\n    computeStyle: {\n      enabled: true,\n      fn: function fn(data) {\n        data.styles = _extends({}, data.styles, {\n          left: '50%',\n          top: '50%',\n          transform: 'translate(-50%, -50%)'\n        });\n        return data;\n      }\n    },\n    addShepherdClass: addShepherdClass\n  }; // Used to compose settings for tippyOptions.popperOptions (https://atomiks.github.io/tippyjs/#popper-options-option)\n\n  var defaultPopperOptions = {\n    positionFixed: true,\n    modifiers: {\n      addShepherdClass: addShepherdClass\n    }\n  };\n  /**\n   * TODO rewrite the way items are being added to use more performant documentFragment code\n   * @param html\n   * @return {HTMLElement} The element created from the passed HTML string\n   */\n\n  function createFromHTML(html) {\n    var el = document.createElement('div');\n    el.innerHTML = html;\n    return el.children[0];\n  }\n  /**\n   * Returns a function, that, as long as it continues to be invoked, will not\n   * be triggered. The function will be called after it stops being called for\n   * N milliseconds. If `immediate` is passed, trigger the function on the\n   * leading edge, instead of the trailing.\n   * @param {Function} func The function to invoke\n   * @param {Number} wait The time to wait in ms\n   * @param {Boolean} immediate If true, the function will be invoked immediately\n   * @return {Function}\n   */\n\n\n  function debounce$2(func, wait, immediate) {\n    var timeout;\n    return function () {\n      var context = this;\n      var args = arguments;\n\n      var later = function later() {\n        timeout = null;\n\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      };\n\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n\n      if (callNow) {\n        func.apply(context, args);\n      }\n    };\n  }\n  /**\n   * Creates a slice of `arr` with n elements dropped from the beginning.\n   * @param {Array} arr\n   * @param {Number} n\n   * @return {*}\n   */\n\n\n  function drop(arr) {\n    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    if (Array.isArray(arr)) {\n      return arr.slice(n);\n    }\n\n    return [];\n  }\n  /**\n   * Parse the position object or string to return the attachment and element to attach to\n   * @param {Object|String} position Either a string or object denoting the selector and position for attachment\n   * @return {Object} The object with `element` and `on` for the step\n   * @private\n   */\n\n\n  function _parseAttachToOpts(opts) {\n    if (lodash_isobjectlike(opts)) {\n      if (opts.hasOwnProperty('element') && opts.hasOwnProperty('on')) {\n        return opts;\n      }\n\n      return null;\n    }\n\n    var positionRe = /^(.+) ((auto|top|left|right|bottom)(-start|-end)?)$/;\n    var matches = positionRe.exec(opts);\n\n    if (!matches) {\n      return null;\n    }\n\n    return {\n      element: matches[1],\n      on: matches[2]\n    };\n  }\n  /**\n   * @param obj\n   * @param {Array} props\n   * @return {*}\n   */\n\n\n  function parseShorthand(obj, props) {\n    if (obj === null || isUndefined(obj)) {\n      return obj;\n    } else if (lodash_isobjectlike(obj)) {\n      return obj;\n    }\n\n    var values = obj.split(' ');\n    return lodash_zipobject(props, values);\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `this.tooltip` as a Tippy.js instance.\n   */\n\n\n  function setupTooltip() {\n    if (isUndefined(tippy)) {\n      throw new Error(missingTippy);\n    }\n\n    if (this.tooltip) {\n      this.tooltip.destroy();\n    }\n\n    var attachToOpts = this.parseAttachTo();\n    this.tooltip = _makeTippyInstance.call(this, attachToOpts);\n    this.target = attachToOpts.element || document.body;\n    this.el.classList.add('shepherd-element');\n  }\n  /**\n   * Passes `options.attachTo` to `_parseAttachToOpts` to get the correct `attachTo` format\n   * @returns {({} & {element, on}) | ({})}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n\n  function parseAttachTo() {\n    var options = _parseAttachToOpts(this.options.attachTo) || {};\n\n    var returnOpts = _extends({}, options);\n\n    if (isString(options.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(options.element);\n      } catch (e) {// TODO\n      }\n\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n\n    return returnOpts;\n  }\n  /**\n   * Generates a `Tippy` instance from a set of base `attachTo` options\n   *\n   * @return {tippy} The final tippy instance\n   * @private\n   */\n\n\n  function _makeTippyInstance(attachToOptions) {\n    if (!attachToOptions.element) {\n      return _makeCenteredTippy.call(this);\n    }\n\n    var tippyOptions = _makeAttachedTippyOptions.call(this, attachToOptions);\n\n    return tippy(attachToOptions.element, tippyOptions);\n  }\n  /**\n   * Generates the hash of options that will be passed to `Tippy` instances\n   * target an element in the DOM.\n   *\n   * @param {Object} attachToOptions The local `attachTo` options\n   * @return {Object} The final tippy options  object\n   * @private\n   */\n\n\n  function _makeAttachedTippyOptions(attachToOptions) {\n    var resultingTippyOptions = {\n      content: this.el,\n      flipOnUpdate: true,\n      placement: attachToOptions.on || 'right'\n    };\n\n    _extends(resultingTippyOptions, this.options.tippyOptions);\n\n    if (this.options.title) {\n      var existingTheme = resultingTippyOptions.theme;\n      resultingTippyOptions.theme = existingTheme ? \"\".concat(existingTheme, \" shepherd-has-title\") : 'shepherd-has-title';\n    }\n\n    if (this.options.tippyOptions && this.options.tippyOptions.popperOptions) {\n      _extends(defaultPopperOptions, this.options.tippyOptions.popperOptions);\n    }\n\n    resultingTippyOptions.popperOptions = defaultPopperOptions;\n    return resultingTippyOptions;\n  }\n  /**\n   * Generates a `Tippy` instance for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @return {tippy} The final tippy instance\n   * @private\n   */\n\n\n  function _makeCenteredTippy() {\n    var tippyOptions = _objectSpread({\n      content: this.el,\n      placement: 'top'\n    }, this.options.tippyOptions);\n\n    tippyOptions.arrow = false;\n    tippyOptions.popperOptions = tippyOptions.popperOptions || {};\n\n    var finalPopperOptions = _extends({}, defaultPopperOptions, tippyOptions.popperOptions, {\n      modifiers: _extends(centeredStylePopperModifier, tippyOptions.popperOptions.modifiers)\n    });\n\n    tippyOptions.popperOptions = finalPopperOptions;\n    return tippy(document.body, tippyOptions);\n  }\n\n  var Evented =\n  /*#__PURE__*/\n  function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx) {\n        var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];\n\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return false;\n        }\n\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          var args = drop(Array.prototype.slice.call(arguments));\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n                handler = binding.handler,\n                once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n      }\n    }]);\n\n    return Evented;\n  }();\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** `Object#toString` result references. */\n\n\n  var objectTag = '[object Object]';\n  /**\n   * Checks if `value` is a host object in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n   */\n\n  function isHostObject(value) {\n    // Many host objects are `Object` objects that can coerce to strings\n    // despite having improperly defined `toString` methods.\n    var result = false;\n\n    if (value != null && typeof value.toString != 'function') {\n      try {\n        result = !!(value + '');\n      } catch (e) {}\n    }\n\n    return result;\n  }\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n  /** Used for built-in method references. */\n\n\n  var funcProto = Function.prototype,\n      objectProto$1 = Object.prototype;\n  /** Used to resolve the decompiled source of functions. */\n\n  var funcToString = funcProto.toString;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty$2 = objectProto$1.hasOwnProperty;\n  /** Used to infer the `Object` constructor. */\n\n  var objectCtorString = funcToString.call(Object);\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n  var objectToString = objectProto$1.toString;\n  /** Built-in value references. */\n\n  var getPrototype = overArg(Object.getPrototypeOf, Object);\n  /**\n   * Checks if `value` is likely a DOM element.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n   * @example\n   *\n   * _.isElement(document.body);\n   * // => true\n   *\n   * _.isElement('<body>');\n   * // => false\n   */\n\n  function isElement(value) {\n    return !!value && value.nodeType === 1 && isObjectLike$1(value) && !isPlainObject(value);\n  }\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n\n  function isObjectLike$1(value) {\n    return !!value && _typeof2(value) == 'object';\n  }\n  /**\n   * Checks if `value` is a plain object, that is, an object created by the\n   * `Object` constructor or one with a `[[Prototype]]` of `null`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.8.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * _.isPlainObject(new Foo);\n   * // => false\n   *\n   * _.isPlainObject([1, 2, 3]);\n   * // => false\n   *\n   * _.isPlainObject({ 'x': 0, 'y': 0 });\n   * // => true\n   *\n   * _.isPlainObject(Object.create(null));\n   * // => true\n   */\n\n\n  function isPlainObject(value) {\n    if (!isObjectLike$1(value) || objectToString.call(value) != objectTag || isHostObject(value)) {\n      return false;\n    }\n\n    var proto = getPrototype(value);\n\n    if (proto === null) {\n      return true;\n    }\n\n    var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;\n    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n  }\n\n  var lodash_iselement = isElement;\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @private\n   */\n\n  function _setupAdvanceOnHandler(selector) {\n    var _this = this;\n\n    return function (event) {\n      if (_this.isOpen()) {\n        var targetIsEl = _this.el && event.target === _this.el;\n        var targetIsSelector = !isUndefined(selector) && event.target.matches(selector);\n\n        if (targetIsSelector || targetIsEl) {\n          _this.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   */\n\n\n  function bindAdvance() {\n    // An empty selector matches the step element\n    var _parseShorthand = parseShorthand(this.options.advanceOn, ['selector', 'event']),\n        event = _parseShorthand.event,\n        selector = _parseShorthand.selector;\n\n    var handler = _setupAdvanceOnHandler.call(this, selector); // TODO: this should also bind/unbind on show/hide\n\n\n    var el = document.querySelector(selector);\n\n    if (!isUndefined(selector) && el) {\n      el.addEventListener(event, handler);\n    } else {\n      document.body.addEventListener(event, handler, true);\n    }\n\n    this.on('destroy', function () {\n      return document.body.removeEventListener(event, handler, true);\n    });\n  }\n  /**\n   * Bind events to the buttons for next, back, etc\n   * @param {Object} cfg An object containing the config options for the button\n   * @param {HTMLElement} el The element for the button\n   */\n\n\n  function bindButtonEvents(cfg, el) {\n    var _this2 = this;\n\n    cfg.events = cfg.events || {};\n\n    if (!isUndefined(cfg.action)) {\n      // Including both a click event and an action is not supported\n      cfg.events.click = cfg.action;\n    }\n\n    if (cfg.events) {\n      Object.entries(cfg.events).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            event = _ref2[0],\n            handler = _ref2[1];\n\n        if (isString(handler)) {\n          var page = handler;\n\n          handler = function handler() {\n            return _this2.tour.show(page);\n          };\n        }\n\n        el.dataset.buttonEvent = true;\n        el.addEventListener(event, handler); // Cleanup event listeners on destroy\n\n        _this2.on('destroy', function () {\n          el.removeAttribute('data-button-event');\n          el.removeEventListener(event, handler);\n        });\n      });\n    }\n  }\n  /**\n   * Add a click listener to the cancel link that cancels the tour\n   * @param {HTMLElement} link The cancel link element\n   */\n\n\n  function bindCancelLink(link) {\n    var _this3 = this;\n\n    link.addEventListener('click', function (e) {\n      e.preventDefault();\n\n      _this3.cancel();\n    });\n  }\n  /**\n   * Take an array of strings and look up methods by name, then bind them to `this`\n   * @param {String[]} methods The names of methods to bind\n   */\n\n\n  function bindMethods(methods) {\n    var _this4 = this;\n\n    methods.map(function (method) {\n      _this4[method] = _this4[method].bind(_this4);\n    });\n  }\n\n  if (!Element.prototype.matches) {\n    Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n  }\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      // polyfill\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof2(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n\n          if (_typeof2(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof2(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset, // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof2(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n\n            original.elementScroll.call(this, // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof2(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft, // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  var smoothscroll_1 = smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * Creates incremented ID for each newly created step\n   *\n   * @private\n   * @return {Number} The unique id for the step\n   */\n\n  var uniqueId = function () {\n    var id = 0;\n    return function () {\n      return ++id;\n    };\n  }();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n\n\n  var Step =\n  /*#__PURE__*/\n  function (_Evented) {\n    _inherits(Step, _Evented);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {Object} options The options for the step\n     * @param {Object|string} options.attachTo What element the step should be attached to on the page.\n     * It can either be a string of the form `[element] [on]` (where [element] is an element selector path):\n     * ```js\n     * const new Step(tour, {\n     *   attachTo: '.some .selector-path left',\n     *   ...moreOptions,\n     * })'\n     * ```\n     * Or an object with those properties:\n     * ```js\n     * const new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * })'\n     * ```\n     * If you use the object syntax, element can also be a DOM element. If you don’t specify an attachTo the\n     * element will appear in the middle of the screen.\n     * @param {HTMLElement|string} options.attachTo.element\n     * @param {string} options.attachTo.on\n     * @param {Object|string} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It can be of the form `\"selector event\"`:\n     * ```js\n     * const new Step(tour, {\n     *   advanceOn: '.some .selector-path click',\n     *   ...moreOptions\n     * })'\n     * ```\n     * ...or an object with those properties:\n     * ```js\n     * const new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * })'\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {Object} options.buttons.button.events A hash of events to bind onto the button, for example\n     * `{'mouseover': function(){}}`. Adding a `click` event to events when you already have an `action` specified is not supported.\n     * You can use events to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * events: {\n     *   click: function() {\n     *     return Shepherd.activeTour.show('some_step_name');\n     *   }\n     * }\n     * ```\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {Object} options.tippyOptions Extra [options to pass to tippy.js]{@link https://atomiks.github.io/tippyjs/#all-options}\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {boolean} options.showCancelLink Should a cancel “✕” be shown in the header of the step?\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of four types:\n     * ```\n     * - HTML string\n     * - Array of HTML strings\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one of the three options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step.\n     * @param {Object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @param {Number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @return {Step} The newly created Step instance\n     */\n\n\n    function Step(tour, options) {\n      var _this;\n\n      _classCallCheck(this, Step);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Step).call(this, tour, options));\n      _this.tour = tour;\n      bindMethods.call(_assertThisInitialized(_this), ['_show', 'cancel', 'complete', 'destroy', 'hide', 'isOpen', 'scrollTo', 'setupElements', 'show']);\n\n      _this.setOptions(options);\n\n      _this.bindAdvance = bindAdvance.bind(_assertThisInitialized(_this));\n      _this.bindButtonEvents = bindButtonEvents.bind(_assertThisInitialized(_this));\n      _this.bindCancelLink = bindCancelLink.bind(_assertThisInitialized(_this));\n      _this.setupTooltip = setupTooltip.bind(_assertThisInitialized(_this));\n      _this.parseAttachTo = parseAttachTo.bind(_assertThisInitialized(_this));\n      return _possibleConstructorReturn(_this, _assertThisInitialized(_this));\n    }\n    /**\n     * Adds buttons to the step as passed into options\n     *\n     * @private\n     * @param {HTMLElement} content The element for the step, to append the footer with buttons to\n     */\n\n\n    _createClass(Step, [{\n      key: \"_addButtons\",\n      value: function _addButtons(content) {\n        var _this2 = this;\n\n        if (Array.isArray(this.options.buttons) && this.options.buttons.length) {\n          var footer = document.createElement('footer');\n          var buttons = createFromHTML('<ul class=\"shepherd-buttons\"></ul>');\n          footer.classList.add('shepherd-footer');\n          this.options.buttons.map(function (cfg) {\n            var button = createFromHTML(\"<li><a class=\\\"shepherd-button \".concat(cfg.classes || '', \"\\\" tabindex=\\\"0\\\">\").concat(cfg.text, \"</a>\"));\n            buttons.appendChild(button);\n\n            _this2.bindButtonEvents(cfg, button.querySelector('a'));\n          });\n          footer.appendChild(buttons);\n          content.appendChild(footer);\n        }\n      }\n      /**\n       * Adds the \"x\" button to cancel the tour\n       * @param {HTMLElement} element The step element\n       * @param {HTMLElement} header The header element for the step\n       * @private\n       */\n\n    }, {\n      key: \"_addCancelLink\",\n      value: function _addCancelLink(element, header) {\n        if (this.options.showCancelLink) {\n          var link = createFromHTML('<a href class=\"shepherd-cancel-link\"></a>');\n          header.appendChild(link);\n          element.classList.add('shepherd-has-cancel-link');\n          this.bindCancelLink(link);\n        }\n      }\n      /**\n       * Adds text passed in as options\n       *\n       * @private\n       * @param {HTMLElement} content The content to append the text to\n       */\n\n    }, {\n      key: \"_addContent\",\n      value: function _addContent(content) {\n        var text = createFromHTML('<div class=\"shepherd-text\"></div>');\n        var paragraphs = this.options.text;\n\n        if (isFunction(paragraphs)) {\n          paragraphs = paragraphs.call(this, text);\n        }\n\n        if (paragraphs instanceof HTMLElement) {\n          text.appendChild(paragraphs);\n        } else {\n          if (isString(paragraphs)) {\n            paragraphs = [paragraphs];\n          }\n\n          paragraphs.map(function (paragraph) {\n            text.innerHTML += \"<p>\".concat(paragraph, \"</p>\");\n          });\n        }\n\n        content.appendChild(text);\n      }\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @private\n       * @return {HTMLElement} The DOM element for the step tooltip\n       */\n\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var content = document.createElement('div');\n        var classes = this.options.classes || '';\n        var element = createFromHTML(\"<div class=\\\"\".concat(classes, \"\\\" data-shepherd-step-id=\\\"\").concat(this.id, \"\\\">\"));\n        var header = document.createElement('header');\n\n        if (this.options.title) {\n          var title = document.createElement('h3');\n          title.classList.add('shepherd-title');\n          title.innerHTML = \"\".concat(this.options.title);\n          header.appendChild(title);\n          element.classList.add('shepherd-has-title');\n        }\n\n        content.classList.add('shepherd-content');\n        header.classList.add('shepherd-header');\n        element.appendChild(content);\n        content.appendChild(header);\n\n        if (!isUndefined(this.options.text)) {\n          this._addContent(content);\n        }\n\n        this._addButtons(content);\n\n        this._addCancelLink(element, header);\n\n        return element;\n      }\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n      /**\n       * Cancel the tour\n       * Triggers the `cancel` event\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n      /**\n       * Remove the step, delete the step's element, and destroy the tippy instance for the step\n       * Triggers `destroy` event\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.tooltip) {\n          this.tooltip.destroy();\n          this.tooltip = null;\n        }\n\n        if (lodash_iselement(this.el) && this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n          this.el = null;\n        }\n\n        if (this.target) {\n          this._updateStepTargetOnHide();\n        }\n\n        this.trigger('destroy');\n      }\n      /**\n       * Hide the step and destroy the tippy instance\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n        document.body.removeAttribute('data-shepherd-step');\n\n        if (this.target) {\n          this._updateStepTargetOnHide();\n        }\n\n        if (this.tooltip) {\n          this.tooltip.hide();\n        }\n\n        this.trigger('hide');\n      }\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.tooltip && this.tooltip.state && this.tooltip.state.isVisible);\n      }\n      /**\n       * Create the element and set up the tippy instance\n       */\n\n    }, {\n      key: \"setupElements\",\n      value: function setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n\n        this.el = this._createTooltipContent();\n\n        if (this.options.advanceOn) {\n          this.bindAdvance();\n        }\n\n        this.setupTooltip();\n      }\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       */\n\n    }, {\n      key: \"scrollTo\",\n      value: function scrollTo(scrollToOptions) {\n        var _this$parseAttachTo = this.parseAttachTo(),\n            element = _this$parseAttachTo.element;\n\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (lodash_iselement(element)) {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       */\n\n    }, {\n      key: \"setOptions\",\n      value: function setOptions() {\n        var _this3 = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.options = options;\n        var when = this.options.when;\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uniqueId());\n\n        if (when) {\n          Object.entries(when).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                event = _ref2[0],\n                handler = _ref2[1];\n\n            _this3.on(event, handler, _this3);\n          });\n        }\n      }\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this4 = this;\n\n        if (isFunction(this.options.beforeShowPromise)) {\n          var beforeShowPromise = this.options.beforeShowPromise();\n\n          if (!isUndefined(beforeShowPromise)) {\n            return beforeShowPromise.then(function () {\n              return _this4._show();\n            });\n          }\n        }\n\n        this._show();\n      }\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a tippy instance for the tooltip, then triggers `show`.\n       * @private\n       */\n\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this5 = this;\n\n        this.tour.beforeShowStep(this);\n        this.trigger('before-show');\n\n        if (!this.el) {\n          this.setupElements();\n        }\n\n        this.target.classList.add('shepherd-enabled', 'shepherd-target');\n        document.body.setAttribute('data-shepherd-step', this.id);\n\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this5.scrollTo(_this5.options.scrollTo);\n          });\n        }\n\n        this.tooltip.show();\n        this.trigger('show');\n      }\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        if (this.options.highlightClass) {\n          this.target.classList.remove(this.options.highlightClass);\n        }\n\n        this.target.classList.remove('shepherd-enabled', 'shepherd-target');\n      }\n    }]);\n\n    return Step;\n  }(Evented);\n\n  var svgNS = 'http://www.w3.org/2000/svg';\n  var elementIds = {\n    modalOverlay: 'shepherdModalOverlayContainer',\n    modalOverlayMask: 'shepherdModalMask',\n    modalOverlayMaskRect: 'shepherdModalMaskRect',\n    modalOverlayMaskOpening: 'shepherdModalMaskOpening'\n  };\n  var classNames = {\n    isVisible: 'shepherd-modal-is-visible',\n    modalTarget: 'shepherd-modal-target'\n  };\n  /**\n   * <svg id=\"shepherdModalOverlayContainer\" xmlns=\"http://www.w3.org/2000/svg\">\n   */\n\n  function _createModalContainer() {\n    var element = document.createElementNS(svgNS, 'svg');\n    element.setAttributeNS(null, 'id', elementIds.modalOverlay);\n    return element;\n  }\n  /**\n   * <mask id=\"shepherdModalMask\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">\n   */\n\n\n  function _createMaskContainer() {\n    var element = document.createElementNS(svgNS, 'mask');\n\n    _setAttributes(element, {\n      height: '100%',\n      id: elementIds.modalOverlayMask,\n      width: '100%',\n      x: '0',\n      y: '0'\n    });\n\n    return element;\n  }\n  /**\n   *  <rect id=\"modalOverlayMaskRect\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"#FFFFFF\"/>\n   */\n\n\n  function _createMaskRect() {\n    var element = document.createElementNS(svgNS, 'rect');\n\n    _setAttributes(element, {\n      fill: '#FFFFFF',\n      height: '100%',\n      id: elementIds.modalOverlayMaskRect,\n      width: '100%',\n      x: '0',\n      y: '0'\n    });\n\n    return element;\n  }\n  /**\n   * <rect id=\"shepherdModalMaskOpening\" fill=\"#000000\"/>\n   */\n\n\n  function _createMaskOpening() {\n    var element = document.createElementNS(svgNS, 'rect');\n\n    _setAttributes(element, {\n      fill: '#000000',\n      id: elementIds.modalOverlayMaskOpening\n    });\n\n    return element;\n  }\n  /**\n   * <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" mask=\"url(#shepherdModalMask)\"/>\n   */\n\n\n  function _createMaskConsumer() {\n    var element = document.createElementNS(svgNS, 'rect');\n\n    _setAttributes(element, {\n      height: '100%',\n      width: '100%',\n      x: '0',\n      y: '0'\n    });\n\n    element.setAttribute('mask', \"url(#\".concat(elementIds.modalOverlayMask, \")\"));\n    return element;\n  }\n  /**\n   * Generates an SVG with the following structure:\n   * ```html\n   *  <svg id=\"shepherdModalOverlayContainer\" xmlns=\"http://www.w3.org/2000/svg\">\n   <defs>\n   <mask id=\"shepherdModalMask\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" >\n   <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"#FFFFFF\"/>\n   <!-- This element will \"punch a hole\" through the mask by preventing it from rendering within the perimeter -->\n   <rect id=\"shepherdModalMaskOpening\"/>\n   </mask>\n   </defs>\n   <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" mask=\"url(#shepherdModalMask)\"/>\n   </svg>\n   * ```\n   */\n\n\n  function createModalOverlay() {\n    var containerElement = _createModalContainer();\n\n    var defsElement = document.createElementNS(svgNS, 'defs');\n\n    var maskContainer = _createMaskContainer();\n\n    var maskRect = _createMaskRect();\n\n    var maskOpening = _createMaskOpening();\n\n    var maskConsumer = _createMaskConsumer();\n\n    maskContainer.appendChild(maskRect);\n    maskContainer.appendChild(maskOpening);\n    defsElement.appendChild(maskContainer);\n    containerElement.appendChild(defsElement);\n    containerElement.appendChild(maskConsumer);\n    return containerElement;\n  }\n  /**\n   * Uses the bounds of the element we want the opening overtop of to set the dimensions of the opening and position it\n   * @param {HTMLElement} targetElement The element the opening will expose\n   * @param {SVGElement} openingElement The svg mask for the opening\n   * @param {Number} modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n   */\n\n\n  function positionModalOpening(targetElement, openingElement) {\n    var modalOverlayOpeningPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (targetElement.getBoundingClientRect && openingElement instanceof SVGElement) {\n      var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          x = _targetElement$getBou.x,\n          y = _targetElement$getBou.y,\n          width = _targetElement$getBou.width,\n          height = _targetElement$getBou.height,\n          left = _targetElement$getBou.left,\n          top = _targetElement$getBou.top; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n\n      _setAttributes(openingElement, {\n        x: (x || left) - modalOverlayOpeningPadding,\n        y: (y || top) - modalOverlayOpeningPadding,\n        width: width + modalOverlayOpeningPadding * 2,\n        height: height + modalOverlayOpeningPadding * 2\n      });\n    }\n  }\n\n  function closeModalOpening(openingElement) {\n    if (openingElement && openingElement instanceof SVGElement) {\n      _setAttributes(openingElement, {\n        height: '0',\n        x: '0',\n        y: '0',\n        width: '0'\n      });\n    }\n  }\n\n  function getModalMaskOpening(modalElement) {\n    return modalElement.querySelector(\"#\".concat(elementIds.modalOverlayMaskOpening));\n  }\n\n  function preventModalBodyTouch(event) {\n    event.preventDefault();\n  }\n\n  function preventModalOverlayTouch(event) {\n    event.stopPropagation();\n  }\n  /**\n   * Remove any leftover modal target classes and add the modal target class to the currentElement\n   * @param {HTMLElement} currentElement The element for the current step\n   */\n\n\n  function toggleShepherdModalClass(currentElement) {\n    var shepherdModal = document.querySelector(\"\".concat(classNames.modalTarget));\n\n    if (shepherdModal) {\n      shepherdModal.classList.remove(classNames.modalTarget);\n    }\n\n    currentElement.classList.add(classNames.modalTarget);\n  }\n  /**\n   * Set multiple attributes on an element, via a hash\n   * @param {HTMLElement|SVGElement} el The element to set the attributes on\n   * @param {Object} attrs A hash of key value pairs for attributes to set\n   * @private\n   */\n\n\n  function _setAttributes(el, attrs) {\n    Object.keys(attrs).forEach(function (key) {\n      el.setAttribute(key, attrs[key]);\n    });\n  }\n  /**\n   * Get the element from an option object\n   *\n   * @method getElementFromObject\n   * @param Object attachTo\n   * @returns {Element}\n   * @private\n   */\n\n\n  function getElementFromObject(attachTo) {\n    var op = attachTo.element;\n\n    if (op instanceof HTMLElement) {\n      return op;\n    }\n\n    return document.querySelector(op);\n  }\n  /**\n   * Return the element for a step\n   *\n   * @method getElementForStep\n   * @param step step the step to get an element for\n   * @returns {Element} the element for this step\n   * @private\n   */\n\n\n  function getElementForStep(step) {\n    var attachTo = step.options.attachTo;\n\n    if (!attachTo) {\n      return null;\n    }\n\n    var type = _typeof(attachTo);\n\n    var element;\n\n    if (type === 'string') {\n      element = getElementFromString(attachTo);\n    } else if (type === 'object') {\n      element = getElementFromObject(attachTo);\n    } else {\n      /* istanbul ignore next: cannot test undefined attachTo, but it does work! */\n      element = null;\n    }\n\n    return element;\n  }\n  /**\n   * Get the element from an option string\n   *\n   * @method getElementFromString\n   * @param element the string in the step configuration\n   * @returns {Element} the element from the string\n   * @private\n   */\n\n\n  function getElementFromString(element) {\n    var _element$split = element.split(' '),\n        _element$split2 = _slicedToArray(_element$split, 1),\n        selector = _element$split2[0];\n\n    return document.querySelector(selector);\n  }\n\n  function addStepEventListeners() {\n    if (typeof this._onScreenChange === 'function') {\n      window.removeEventListener('resize', this._onScreenChange, false);\n      window.removeEventListener('scroll', this._onScreenChange, true);\n    }\n\n    window.addEventListener('resize', this._onScreenChange, false);\n    window.addEventListener('scroll', this._onScreenChange, true);\n    var overlay = document.querySelector(\"#\".concat(elementIds.modalOverlay)); // Prevents window from moving on touch.\n\n    window.addEventListener('touchmove', preventModalBodyTouch, {\n      passive: false\n    }); // Allows content to move on touch.\n\n    if (overlay) {\n      overlay.addEventListener('touchmove', preventModalOverlayTouch, false);\n    }\n  }\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n\n\n  var FUNC_ERROR_TEXT = 'Expected a function';\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0:\n        return func.call(thisArg);\n\n      case 1:\n        return func.call(thisArg, args[0]);\n\n      case 2:\n        return func.call(thisArg, args[0], args[1]);\n\n      case 3:\n        return func.call(thisArg, args[0], args[1], args[2]);\n    }\n\n    return func.apply(thisArg, args);\n  }\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n\n\n  var nativeMax = Math.max;\n  /**\n   * The base implementation of `_.delay` and `_.defer` which accepts `args`\n   * to provide to `func`.\n   *\n   * @private\n   * @param {Function} func The function to delay.\n   * @param {number} wait The number of milliseconds to delay invocation.\n   * @param {Array} args The arguments to provide to `func`.\n   * @returns {number} Returns the timer id.\n   */\n\n  function baseDelay(func, wait, args) {\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n\n    return setTimeout(function () {\n      func.apply(undefined, args);\n    }, wait);\n  }\n  /**\n   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function baseRest(func, start) {\n    start = nativeMax(start === undefined ? func.length - 1 : start, 0);\n    return function () {\n      var args = arguments,\n          index = -1,\n          length = nativeMax(args.length - start, 0),\n          array = Array(length);\n\n      while (++index < length) {\n        array[index] = args[start + index];\n      }\n\n      index = -1;\n      var otherArgs = Array(start + 1);\n\n      while (++index < start) {\n        otherArgs[index] = args[index];\n      }\n\n      otherArgs[start] = array;\n      return apply(func, this, otherArgs);\n    };\n  }\n  /**\n   * Defers invoking the `func` until the current call stack has cleared. Any\n   * additional arguments are provided to `func` when it's invoked.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to defer.\n   * @param {...*} [args] The arguments to invoke `func` with.\n   * @returns {number} Returns the timer id.\n   * @example\n   *\n   * _.defer(function(text) {\n   *   console.log(text);\n   * }, 'deferred');\n   * // => Logs 'deferred' after one or more milliseconds.\n   */\n\n\n  var defer = baseRest(function (func, args) {\n    return baseDelay(func, 1, args);\n  });\n  var lodash_defer = defer;\n\n  var Modal =\n  /*#__PURE__*/\n  function () {\n    function Modal(options) {\n      _classCallCheck(this, Modal);\n\n      this.createModalOverlay();\n      this.options = options;\n      return this;\n    }\n    /**\n     * Removes svg mask from modal overlay and removes classes for modal being visible\n     */\n\n\n    _createClass(Modal, [{\n      key: \"cleanup\",\n      value: function cleanup() {\n        var _this = this;\n\n        lodash_defer(function () {\n          var element = _this._modalOverlayElem;\n\n          if (element && element instanceof SVGElement) {\n            element.parentNode.removeChild(element);\n          }\n\n          _this._modalOverlayElem = null;\n          document.body.classList.remove(classNames.isVisible);\n        });\n      }\n      /**\n       * Create the modal overlay, if it does not already exist\n       */\n\n    }, {\n      key: \"createModalOverlay\",\n      value: function createModalOverlay$1() {\n        if (!this._modalOverlayElem) {\n          this._modalOverlayElem = createModalOverlay();\n          this._modalOverlayOpening = getModalMaskOpening(this._modalOverlayElem); // don't show yet -- each step will control that\n\n          this.hide();\n          document.body.appendChild(this._modalOverlayElem);\n        }\n      }\n      /**\n       * Hide the modal overlay\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        document.body.classList.remove(classNames.isVisible);\n\n        if (this._modalOverlayElem) {\n          this._modalOverlayElem.style.display = 'none';\n        }\n      }\n      /**\n       * If modal is enabled, setup the svg mask opening and modal overlay for the step\n       * @param step\n       */\n\n    }, {\n      key: \"setupForStep\",\n      value: function setupForStep(step) {\n        if (this.options.useModalOverlay) {\n          this._styleForStep(step);\n\n          this.show();\n        } else {\n          this.hide();\n        }\n      }\n      /**\n       * Show the modal overlay\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        document.body.classList.add(classNames.isVisible);\n\n        if (this._modalOverlayElem) {\n          this._modalOverlayElem.style.display = 'block';\n        }\n      }\n      /**\n       * Style the modal for the step\n       * @param {Step} step The step to style the opening for\n       * @private\n       */\n\n    }, {\n      key: \"_styleForStep\",\n      value: function _styleForStep(step) {\n        var modalOverlayOpening = this._modalOverlayOpening;\n        var targetElement = getElementForStep(step);\n        var modalOverlayOpeningPadding = step.options.modalOverlayOpeningPadding;\n\n        if (targetElement) {\n          positionModalOpening(targetElement, modalOverlayOpening, modalOverlayOpeningPadding);\n          this._onScreenChange = debounce$2(positionModalOpening.bind(this, targetElement, modalOverlayOpening, modalOverlayOpeningPadding), 0);\n          addStepEventListeners.call(this);\n        } else {\n          closeModalOpening(this._modalOverlayOpening);\n        }\n      }\n    }]);\n\n    return Modal;\n  }();\n\n  var defaults = {\n    trigger: 'manual',\n    arrow: true,\n    animation: 'fade',\n    duration: 420,\n    flip: true,\n    animateFill: false,\n    // https://atomiks.github.io/tippyjs/#animate-fill-option\n    interactive: true,\n    // https://atomiks.github.io/tippyjs/#interactive-option\n    hideOnClick: 'toggle',\n    // https://atomiks.github.io/tippyjs/#hide-on-click-option\n    multiple: true // https://atomiks.github.io/tippyjs/#multiple-option\n\n  };\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          var stepElement = getElementForStep(step);\n\n          if (stepElement instanceof HTMLElement) {\n            stepElement.style.pointerEvents = 'auto';\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Remove resize and scroll event listeners\n   */\n\n\n  function cleanupStepEventListeners() {\n    if (typeof this._onScreenChange === 'function') {\n      window.removeEventListener('resize', this._onScreenChange, false);\n      window.removeEventListener('scroll', this._onScreenChange, false);\n      this._onScreenChange = null;\n    }\n\n    window.removeEventListener('touchmove', preventModalBodyTouch, {\n      passive: false\n    });\n  }\n  /**\n   * Creates incremented ID for each newly created tour\n   *\n   * @private\n   * @return {Number} The unique id for the tour\n   */\n\n\n  var uniqueId$1 = function () {\n    var id = 0;\n    return function () {\n      return ++id;\n    };\n  }();\n\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n\n  var Tour =\n  /*#__PURE__*/\n  function (_Evented) {\n    _inherits(Tour, _Evented);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {Step[]} options.steps An array of Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n\n\n    function Tour() {\n      var _this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, Tour);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Tour).call(this, options));\n      bindMethods.call(_assertThisInitialized(_this), ['back', 'cancel', 'complete', 'hide', 'next']);\n      _this.options = options;\n      _this.steps = _this.options.steps || []; // Pass these events onto the global Shepherd object\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n      _this.modal = new Modal(options);\n\n      _this._setTooltipDefaults();\n\n      _this._setTourID();\n\n      return _possibleConstructorReturn(_this, _assertThisInitialized(_this));\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Number|Step|String} arg1\n     * When arg2 is defined, arg1 can either be a string or number, to use for the `id` for the step\n     * When arg2 is undefined, arg1 is either an object containing step options or a Step instance\n     * @param {Object|Step} arg2 An object containing step options or a Step instance\n     * @return {Step} The newly added step\n     */\n\n\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(arg1, arg2) {\n        var name, step; // If we just have one argument, we can assume it is an object of step options, with an id\n\n        if (isUndefined(arg2)) {\n          step = arg1;\n        } else {\n          name = arg1;\n          step = arg2;\n        }\n\n        if (!(step instanceof Step)) {\n          step = this.setupStep(step, name);\n        } else {\n          step.tour = this;\n        }\n\n        this.steps.push(step);\n        return step;\n      }\n      /**\n       * Go to the previous step in the tour\n       */\n\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n      /**\n       * Calls done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        if (this.options.confirmCancel) {\n          var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n          var stopTour = window.confirm(cancelMessage);\n\n          if (stopTour) {\n            this.done('cancel');\n          }\n        } else {\n          this.done('cancel');\n        }\n      }\n      /**\n       * Calls done() triggering the `complete` event\n       */\n\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.done('complete');\n      }\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       */\n\n    }, {\n      key: \"done\",\n      value: function done(event) {\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n\n        cleanupStepEventListeners.call(this);\n        cleanupSteps(this.tourObject);\n        this.modal.cleanup();\n        this.trigger(event);\n        Shepherd.activeTour = null;\n\n        this._removeBodyAttrs();\n\n        this.trigger('inactive', {\n          tour: this\n        });\n      }\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n      /**\n       * Hide the current step\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this2 = this;\n\n        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n\n            step.destroy();\n\n            _this2.steps.splice(i, 1);\n\n            return true;\n          }\n        });\n\n        if (current && current.id === name) {\n          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n      /**\n       * Setup a new step object\n       * @param {Object} stepOptions The object describing the options for the step\n       * @param {String|Number} name The string or number to use as the `id` for the step\n       * @return {Step} The step instance\n       */\n\n    }, {\n      key: \"setupStep\",\n      value: function setupStep(stepOptions, name) {\n        if (isString(name) || isNumber(name)) {\n          stepOptions.id = name.toString();\n        }\n\n        stepOptions = _extends({}, this.options.defaultStepOptions, stepOptions);\n        return new Step(this, stepOptions);\n      }\n    }, {\n      key: \"beforeShowStep\",\n      value: function beforeShowStep(step) {\n        this.modal.setupForStep(step);\n\n        this._styleTargetElementForStep(step);\n      }\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n\n        if (step) {\n          this._updateStateBeforeShow();\n\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n      /**\n       * Start the tour\n       */\n\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start');\n        this.currentStep = null;\n\n        this._setupActiveTour();\n\n        this.next();\n      }\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.modal.createModalOverlay();\n\n        this._addBodyAttrs();\n\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = getElementForStep(step);\n\n        if (!targetElement) {\n          return;\n        }\n\n        toggleShepherdModalClass(targetElement);\n\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n\n        if (step.options.canClickTarget === false) {\n          targetElement.style.pointerEvents = 'none';\n        }\n      }\n      /**\n       * Called when `showOn` evaluates to false, to skip the step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        var nextIndex = forward ? index + 1 : index - 1;\n        this.show(nextIndex, forward);\n      }\n      /**\n       * Set the tippy defaults\n       * @private\n       */\n\n    }, {\n      key: \"_setTooltipDefaults\",\n      value: function _setTooltipDefaults() {\n        tippy.setDefaults(defaults);\n      }\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        var uuid = uniqueId$1();\n        this.id = \"\".concat(tourName, \"--\").concat(uuid);\n      }\n      /**\n       * Adds the data-shepherd-active-tour attribute and the 'shepherd-active'\n       * class to the body.\n       * @private\n       */\n\n    }, {\n      key: \"_addBodyAttrs\",\n      value: function _addBodyAttrs() {\n        document.body.setAttribute('data-shepherd-active-tour', this.id);\n        document.body.classList.add('shepherd-active');\n      }\n      /**\n       * Removes the data-shepherd-active-tour attribute and the 'shepherd-active'\n       * class from the body.\n       * @private\n       */\n\n    }, {\n      key: \"_removeBodyAttrs\",\n      value: function _removeBodyAttrs() {\n        document.body.removeAttribute('data-shepherd-active-tour');\n        document.body.classList.remove('shepherd-active');\n      }\n    }]);\n\n    return Tour;\n  }(Evented);\n\n  _extends(Shepherd, {\n    Tour: Tour,\n    Step: Step,\n    Evented: Evented\n  });\n\n  return Shepherd;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/shepherd.js/dist/js/shepherd.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ })

/******/ });
});;